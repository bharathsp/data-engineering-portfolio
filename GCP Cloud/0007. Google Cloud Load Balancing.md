# üö¶ What is Google Cloud Load Balancing?

Google Cloud Load Balancing is a **fully-managed, software-defined load-balancing service** that distributes user traffic across backends (VMs, containers, serverless, storage) and can operate **globally or regionally** with a single anycast IP for global L7 traffic. It‚Äôs designed to scale to millions of requests per second and to react instantly to changes in traffic or backend health. ([Google Cloud][1])

---

# ‚öôÔ∏è Key capabilities (at-a-glance)

* üåç **Global anycast front end** ‚Äî one IP can serve global traffic with cross-region failover. ([Google Cloud][2])
* üîÄ **Layer-7 (HTTP(S)) and Layer-4 (TCP/UDP) options** ‚Äî choose proxy (L7/L4) or pass-through network load balancing. ([Google Cloud][3])
* üß∞ **Multiple backend types** ‚Äî instance groups, Network Endpoint Groups (NEGs) for pods/serverless, Cloud Storage buckets, Internet NEGs. ([Google Cloud][4])
* üõ°Ô∏è **Security & acceleration** ‚Äî integrates with **Cloud Armor** (WAF / DDoS protection) and **Cloud CDN** for caching. ([Google Cloud][5])
* üìà **Autoscaling & health checks** ‚Äî backends scale and traffic is routed away from unhealthy servers automatically. ([Google Cloud][1])

---

# üî© How GCLB is structured (components & flow)

(Short flow with icons)

```
[üåê Client] ‚Üí [üì® Forwarding rule (IP:port)] ‚Üí [üéØ Target proxy / Target pool] ‚Üí [üß≠ URL map / Host/path rules] ‚Üí [üîô Backend service] ‚Üí [üñ•Ô∏è Backends (instance groups / NEGs / buckets)]
```

* **Forwarding rule**: binds an IP/port to the LB.
* **Target proxy / target pool**: proxy that understands HTTP(S) or TCP and uses the URL map or backend service to route.
* **URL map** (L7): route by hostname/path to different backend services (canary, microservices, static assets).
* **Backend service**: defines backends, balancing mode, session affinity, timeout, and health checks.
* **Backends**: instance groups, zonal NEGs, serverless NEGs (Cloud Run, App Engine, Cloud Functions), or storage buckets. ([Google Cloud][4])

---

# üß≠ Types of GCP Load Balancers & when to use each

(choose based on traffic type: external vs internal, global vs regional, L7 vs L4)

1. **Global External HTTP(S) Load Balancer** (L7, proxy)

   * Use for internet-facing web apps with global reach, TLS termination at edge, URL routing, Cloud CDN & Cloud Armor integration, and cross-region failover. Ideal for multi-region web front ends. ([Google Cloud][2])

2. **SSL Proxy Load Balancer & TCP Proxy Load Balancer** (global, L4/L7 variants)

   * Use when you need TLS termination (SSL Proxy) or proxying of TCP flows (TCP Proxy) at the edge, supporting large client connection counts and enabling access control at the edge. ([Google Cloud][3])

3. **Network Load Balancer (External)** (L4, pass-through)

   * Regional, high-performance, low-latency pass-through for arbitrary TCP/UDP traffic. Works well for protocols where you don‚Äôt want termination/proxying. ([Google Cloud][3])

4. **Internal TCP/UDP Load Balancer** (regional, L4)

   * Use for private/inside-VPC traffic (databases, internal microservices) ‚Äî exposes internal IPs only. ([Google Cloud][3])

5. **Internal HTTP(S) Load Balancer** (regional, L7)

   * For internal L7 routing within VPCs (service mesh entry, internal APIs). Supports URL maps but is regionally scoped. ([Google Cloud][3])

6. **GKE / Serverless + NEGs**

   * For Kubernetes pods or serverless services, use **NEGs** to route at the pod or service level (more granular than instance groups). Also enable hybrid origins (external origins via Internet NEGs). ([Google Cloud][4])

---

# üîê Security & acceleration integrations

* **Cloud Armor**: apply WAF rules, IP allow/deny, rate limiting, and adaptive protections at the edge (before traffic hits backends). ([Google Cloud][6])
* **Cloud CDN**: caches HTTP(S) content at Google's edge PoPs; works with global external HTTP(S) LB to reduce origin load and latency. ([Google Cloud][5])

---

# ‚úÖ Typical architecture patterns (examples)

* **Global web app**: Global HTTP(S) LB + URL map ‚Üí backends in multiple regions (instance groups/NEGs) + Cloud CDN + Cloud Armor. (cross-region failover, single anycast IP) ([Google Cloud][2])
* **Microservices / GKE**: External LB ‚Üí serverless NEGs / GKE NEGs for pod-level routing + health checks + autoscaling. ([Google Cloud][4])
* **Internal service mesh / private APIs**: Internal HTTP(S) LB or Internal TCP/UDP LB + internal IPs and firewall rules. ([Google Cloud][3])

---

# ‚ö†Ô∏è Common design considerations & pitfalls

* **Global vs Regional**: Global LBs provide anycast + cross-region failover and CDN/WAF integration; regional LBs are limited to a region (use internal LBs or network LBs for low latency/regional constraints). ([Google Cloud][2])
* **Health checks matter**: incorrect health checks will route traffic to unhealthy backends or mark healthy ones as unhealthy. Tune timeouts and paths. ([Google Cloud][1])
* **Session affinity**: if you need sticky sessions, configure backend service affinity correctly (but understand scaling and cache implications). ([Google Cloud][3])
* **Firewall & IAM**: ensure health check IPs are allowed, and service accounts/roles are configured for autoscaling & NEGs. ([Google Cloud][3])
* **Cost & quota**: global proxy LBs + CDN + Cloud Armor each have costs ‚Äî plan traffic patterns & caching strategy. ([Google Cloud][1])

---

# üõ†Ô∏è Operational tips

* Use **NEGs** for GKE/serverless to get finer-grained, pod/service level routing. ([Google Cloud][4])
* Place static assets behind **Cloud CDN** to reduce backend load and latency. ([Google Cloud][5])
* Use **URL maps** for blue/green or canary deployments (route a % of traffic to new backends). ([Google Cloud][3])
* Monitor LB metrics (requests/sec, backend latency, unhealthy backends) via **Cloud Monitoring & Logging**.

---

# Quick checklist when choosing a load balancer

* Is traffic **internet-facing** or **internal**? (external ‚Üí global or regional external LB; internal ‚Üí internal LB)
* Do you need **TLS termination, URL routing, CDN, or WAF**? (use global HTTP(S) LB)
* Do you need **pod/serverless-level** routing? (use NEGs)
* Are you optimizing for **latency** (regional) or **global reach / failover** (global anycast)?
