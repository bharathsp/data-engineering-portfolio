# SOLID principles

The SOLID principles are **five** design principles for writing clean, maintainable, and scalable object-oriented code.

---

## **S** â€” **Single Responsibility Principle (SRP)**

ðŸ“œ **Definition**: A class should have **one and only one reason to change**.
It should focus on **a single job**.

**Example (Bad)**

```python
class Invoice:
    def calculate_total(self):
        pass
    def save_to_db(self):
        pass
    def print_invoice(self):
        pass
```

Here, `Invoice` is handling **calculation**, **database saving**, and **printing** â€” multiple responsibilities.

**Example (Good)**

```python
class InvoiceCalculator:
    def calculate_total(self):
        pass

class InvoiceRepository:
    def save_to_db(self):
        pass

class InvoicePrinter:
    def print_invoice(self):
        pass
```

Now, each class has **one responsibility**.

---

## **O** â€” **Open/Closed Principle (OCP)**

ðŸ“œ **Definition**: Software entities should be **open for extension** but **closed for modification**.
You should be able to **add new behavior without modifying existing code**.

**Example (Bad)**

```python
class AreaCalculator:
    def calculate(self, shape):
        if shape["type"] == "circle":
            return 3.14 * shape["radius"] ** 2
        elif shape["type"] == "square":
            return shape["side"] ** 2
```

Every time a new shape is added, we **modify** the method.

**Example (Good â€” Open for extension)**

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    def area(self):
        return 3.14 * self.radius ** 2

class Square(Shape):
    def __init__(self, side):
        self.side = side
    def area(self):
        return self.side ** 2

class AreaCalculator:
    def calculate(self, shape: Shape):
        return shape.area()
```

Now, new shapes can be added without touching `AreaCalculator`.

---

## **L** â€” **Liskov Substitution Principle (LSP)**

ðŸ“œ **Definition**: **Subclasses should be replaceable** with their parent class **without breaking functionality**.

**Example (Bad)**

```python
class Bird:
    def fly(self):
        pass

class Ostrich(Bird):
    def fly(self):
        raise Exception("Ostrich can't fly!")
```

This breaks substitution â€” replacing `Bird` with `Ostrich` will cause errors.

**Example (Good)**

```python
class Bird:
    pass

class FlyingBird(Bird):
    def fly(self):
        pass

class Ostrich(Bird):
    def run(self):
        pass
```

We separate flying birds into their own type.

---

## **I** â€” **Interface Segregation Principle (ISP)**

ðŸ“œ **Definition**: No client should be **forced to depend on methods** it does not use.
Better to have **many small interfaces** than one large one.

**Example (Bad)**

```python
class Worker:
    def work(self): pass
    def eat(self): pass

class Robot(Worker):
    def eat(self):
        raise Exception("Robots don't eat")
```

Robot is forced to implement `eat()` which it doesn't need.

**Example (Good)**

```python
class Workable:
    def work(self): pass

class Eatable:
    def eat(self): pass

class Human(Workable, Eatable):
    def work(self): pass
    def eat(self): pass

class Robot(Workable):
    def work(self): pass
```

Now, each implements **only what it needs**.

---

## **D** â€” **Dependency Inversion Principle (DIP)**

ðŸ“œ **Definition**: **High-level modules** should not depend on **low-level modules**. Both should depend on **abstractions**.

**Example (Bad)**

```python
class MySQLDatabase:
    def connect(self):
        pass

class Application:
    def __init__(self):
        self.db = MySQLDatabase()  # tightly coupled
```

If you change the DB to PostgreSQL, you have to modify `Application`.

**Example (Good)**

```python
from abc import ABC, abstractmethod

class Database(ABC):
    @abstractmethod
    def connect(self):
        pass

class MySQLDatabase(Database):
    def connect(self):
        pass

class PostgreSQLDatabase(Database):
    def connect(self):
        pass

class Application:
    def __init__(self, db: Database):
        self.db = db
```

Now, we can swap databases without changing `Application`.

---

âœ… **Summary Table**

| Principle | Purpose                                      |
| --------- | -------------------------------------------- |
| SRP       | One reason to change                         |
| OCP       | Add features without modifying existing code |
| LSP       | Subclasses should work as base class         |
| ISP       | No unnecessary method implementation         |
| DIP       | Depend on abstractions, not concrete classes |

---
