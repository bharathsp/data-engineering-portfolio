# 📌 What are **Design Patterns**?

👉 **Design Patterns** are **proven, reusable solutions** to common problems that occur in software design.

They are **not code snippets** to copy-paste, but **blueprints or templates** 👷‍♂️ that guide you in solving problems in a clean, maintainable, and reusable way.

Think of them like **recipes 🍲** → they don’t give you the exact meal, but the method to cook it.

---

## 🎯 Why Use Design Patterns?

* ✅ Provide **standard solutions** to recurring problems.
* ✅ Improve **code readability** (developers recognize patterns easily).
* ✅ Promote **reusability** and **scalability**.
* ✅ Reduce risk of **bad design choices**.

---

# 🛠️ Types of Design Patterns (GoF – Gang of Four Classification)

The **Gang of Four (GoF)** book defined **23 classic patterns**, grouped into 3 categories:

---

## 1️⃣ **Creational Patterns** 🏗️

<img width="401" height="201" alt="image" src="https://github.com/user-attachments/assets/089da25e-d0ce-4948-85b1-17931068989e" />

👉 Deal with **object creation mechanisms**. They help in making a system independent of how its objects are created, composed and represented. 
Instead of creating objects directly using new, these patterns make the creation process flexible and reusable.

Examples:

* **Singleton** → Ensure only one instance of a class exists (e.g., DB connection).
* **Factory Method** → Create objects without exposing creation logic.
* **Abstract Factory Method** → Provides an interface to create families of related objects without specifying their concrete classes.
* **Builder** → Step-by-step construction of complex objects.
* **Prototype Method** → Creates new objects by cloning existing objects (prototypes) instead of creating from scratch.

---

## 2️⃣ **Structural Patterns** 🧩

<img width="401" height="201" alt="image" src="https://github.com/user-attachments/assets/59a7df5b-fe56-42be-8905-854be99b3c7f" />

👉 Deal with **object composition** (how classes/objects are combined). Structural class patterns use inheritance to compose interfaces or implementations.
Help ensure that parts of a system fit together efficiently while keeping them flexible.

Examples:
* **Adapter** → Convert one interface into another (like a power plug adapter 🔌).
* **Decorator** → Add behavior to objects dynamically (like adding toppings to a pizza 🍕).
* **Facade** → Provide a simplified interface to a complex system (like a TV remote 📺 that hides internal circuits).
* **Bridge** → Decouple abstraction from implementation so both can vary independently (like separating a remote control 🕹️ from different TV brands).
* **Composite** → Treat individual objects and groups of objects uniformly (like folders and files in a file system 📂📄).
* **Proxy** → Provide a placeholder for another object to control access (like a personal assistant 👩‍💼 managing access to a busy CEO).
* **Flyweight** → Share common parts of objects to save memory (like reusing chess piece objects ♟️ instead of creating new ones for every game).

---

## 3️⃣ **Behavioral Patterns** 🎭

<img width="1001" height="501" alt="image" src="https://github.com/user-attachments/assets/65ed4ed8-c8f7-4354-ae3e-0dbe3b7d3579" />

👉 Deal with **communication between objects**. Behavioral patterns describe not just patterns of objects or classes but also the patterns of communication between them. 
These patterns characterize complex control flow that’s difficult to follow at run-time. Focus on how objects communicate, delegate tasks, and maintain flexibility in workflows.

Examples:
* **State** → Allow an object to change its behavior when its internal state changes (like a vending machine behaving differently when it’s *idle*, *waiting for payment*, or *dispensing* 🍫).
* **Chain of Responsibility** → Pass a request along a chain of handlers until one handles it (like customer service escalation: chatbot → agent → manager 📞).
* **Template** → Define the skeleton of an algorithm but let subclasses define specific steps (like a cooking recipe 🍲 where steps are fixed, but ingredients may vary).
* **Interpreter** → Define a grammar for a language and provide an interpreter to interpret sentences (like a calculator interpreting math expressions ➕➖✖️➗).
* **Visitor** → Separate an algorithm from the object structure it operates on (like a tax calculator visiting different types of products 🛒).
* **Mediator** → Encapsulate communication between objects, avoiding direct connections (like an air traffic controller 🛫 coordinating between pilots).
* **Memento** → Capture and restore an object’s state without exposing its details (like a “save game” and “load game” feature 🎮).

---

**Problem** ❓ → Apply **Design Pattern (🧩 Blueprint)** → Get **Reusable Solution ✅**

Examples:

* Database connection → **Singleton 🏗️**
* Payment methods → **Strategy 🎭**
* Notification system → **Observer 👀**

---

* **Design Patterns** = reusable solutions to common software design problems.
* Provide **templates**, not exact code.
* Types:

  * **Creational** → object creation 🏗️
  * **Structural** → object composition 🧩
  * **Behavioral** → object interaction 🎭
* They improve **readability, maintainability, and scalability** of code.
