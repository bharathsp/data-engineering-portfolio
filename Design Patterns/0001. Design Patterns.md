# ğŸ“Œ What are **Design Patterns**?

ğŸ‘‰ **Design Patterns** are **proven, reusable solutions** to common problems that occur in software design.

They are **not code snippets** to copy-paste, but **blueprints or templates** ğŸ‘·â€â™‚ï¸ that guide you in solving problems in a clean, maintainable, and reusable way.

Think of them like **recipes ğŸ²** â†’ they donâ€™t give you the exact meal, but the method to cook it.

---

## ğŸ¯ Why Use Design Patterns?

* âœ… Provide **standard solutions** to recurring problems.
* âœ… Improve **code readability** (developers recognize patterns easily).
* âœ… Promote **reusability** and **scalability**.
* âœ… Reduce risk of **bad design choices**.

---

# ğŸ› ï¸ Types of Design Patterns (GoF â€“ Gang of Four Classification)

The **Gang of Four (GoF)** book defined **23 classic patterns**, grouped into 3 categories:

---

## 1ï¸âƒ£ **Creational Patterns** ğŸ—ï¸

<img width="401" height="201" alt="image" src="https://github.com/user-attachments/assets/089da25e-d0ce-4948-85b1-17931068989e" />

ğŸ‘‰ Deal with **object creation mechanisms**. They help in making a system independent of how its objects are created, composed and represented. 
Instead of creating objects directly using new, these patterns make the creation process flexible and reusable.

Examples:

* **Singleton** â†’ Ensure only one instance of a class exists (e.g., DB connection).
* **Factory Method** â†’ Create objects without exposing creation logic.
* **Abstract Factory Method** â†’ Provides an interface to create families of related objects without specifying their concrete classes.
* **Builder** â†’ Step-by-step construction of complex objects.
* **Prototype Method** â†’ Creates new objects by cloning existing objects (prototypes) instead of creating from scratch.

---

## 2ï¸âƒ£ **Structural Patterns** ğŸ§©

<img width="401" height="201" alt="image" src="https://github.com/user-attachments/assets/59a7df5b-fe56-42be-8905-854be99b3c7f" />

ğŸ‘‰ Deal with **object composition** (how classes/objects are combined). Structural class patterns use inheritance to compose interfaces or implementations.
Help ensure that parts of a system fit together efficiently while keeping them flexible.

Examples:
* **Adapter** â†’ Convert one interface into another (like a power plug adapter ğŸ”Œ).
* **Decorator** â†’ Add behavior to objects dynamically (like adding toppings to a pizza ğŸ•).
* **Facade** â†’ Provide a simplified interface to a complex system (like a TV remote ğŸ“º that hides internal circuits).
* **Bridge** â†’ Decouple abstraction from implementation so both can vary independently (like separating a remote control ğŸ•¹ï¸ from different TV brands).
* **Composite** â†’ Treat individual objects and groups of objects uniformly (like folders and files in a file system ğŸ“‚ğŸ“„).
* **Proxy** â†’ Provide a placeholder for another object to control access (like a personal assistant ğŸ‘©â€ğŸ’¼ managing access to a busy CEO).
* **Flyweight** â†’ Share common parts of objects to save memory (like reusing chess piece objects â™Ÿï¸ instead of creating new ones for every game).

---

## 3ï¸âƒ£ **Behavioral Patterns** ğŸ­

<img width="1001" height="501" alt="image" src="https://github.com/user-attachments/assets/65ed4ed8-c8f7-4354-ae3e-0dbe3b7d3579" />

ğŸ‘‰ Deal with **communication between objects**. Behavioral patterns describe not just patterns of objects or classes but also the patterns of communication between them. 
These patterns characterize complex control flow thatâ€™s difficult to follow at run-time. Focus on how objects communicate, delegate tasks, and maintain flexibility in workflows.

Examples:
* **State** â†’ Allow an object to change its behavior when its internal state changes (like a vending machine behaving differently when itâ€™s *idle*, *waiting for payment*, or *dispensing* ğŸ«).
* **Chain of Responsibility** â†’ Pass a request along a chain of handlers until one handles it (like customer service escalation: chatbot â†’ agent â†’ manager ğŸ“).
* **Template** â†’ Define the skeleton of an algorithm but let subclasses define specific steps (like a cooking recipe ğŸ² where steps are fixed, but ingredients may vary).
* **Interpreter** â†’ Define a grammar for a language and provide an interpreter to interpret sentences (like a calculator interpreting math expressions â•â–âœ–ï¸â—).
* **Visitor** â†’ Separate an algorithm from the object structure it operates on (like a tax calculator visiting different types of products ğŸ›’).
* **Mediator** â†’ Encapsulate communication between objects, avoiding direct connections (like an air traffic controller ğŸ›« coordinating between pilots).
* **Memento** â†’ Capture and restore an objectâ€™s state without exposing its details (like a â€œsave gameâ€ and â€œload gameâ€ feature ğŸ®).

---

**Problem** â“ â†’ Apply **Design Pattern (ğŸ§© Blueprint)** â†’ Get **Reusable Solution âœ…**

Examples:

* Database connection â†’ **Singleton ğŸ—ï¸**
* Payment methods â†’ **Strategy ğŸ­**
* Notification system â†’ **Observer ğŸ‘€**

---

* **Design Patterns** = reusable solutions to common software design problems.
* Provide **templates**, not exact code.
* Types:

  * **Creational** â†’ object creation ğŸ—ï¸
  * **Structural** â†’ object composition ğŸ§©
  * **Behavioral** â†’ object interaction ğŸ­
* They improve **readability, maintainability, and scalability** of code.
