# 🔄 **What is a Recursive Function?**

* A **recursive function** is a function that **calls itself** to solve a smaller version of the same problem.
* It keeps breaking the problem down until it hits a **base case** (stopping condition).

👉 Two key parts of recursion:

1. **Base Case** → when to stop (prevents infinite loops).
2. **Recursive Case** → when the function calls itself with a smaller input.

---

# 🖼️ Analogy

Imagine **Russian nesting dolls 🎎**:

* Each doll contains a smaller one inside.
* You keep opening until you reach the smallest doll (base case).
* Then you “stack them back up” (returning results).

---

# 🏗️ Example 1: Factorial

Factorial (n!) = n × (n-1) × (n-2) … × 1

```python
def factorial(n):
    if n == 0 or n == 1:   # Base case
        return 1
    else:                  # Recursive case
        return n * factorial(n-1)

print(factorial(5))  # 120
```

➡️ Flow for `factorial(5)`:

```
5 * factorial(4)
   4 * factorial(3)
      3 * factorial(2)
         2 * factorial(1)
            1  (base case)
```

---

# 🏗️ Example 2: Fibonacci Sequence

Fibonacci: 0, 1, 1, 2, 3, 5, 8, …

```python
def fibonacci(n):
    if n == 0:      # Base case
        return 0
    elif n == 1:
        return 1
    else:           # Recursive case
        return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(6))  # 8
```

➡️ Flow:

```
fibonacci(6) → fibonacci(5) + fibonacci(4)
```

…and so on, until reaching 0 and 1.

---

# 🏗️ Example 3: Sum of a List

```python
def list_sum(arr):
    if len(arr) == 0:   # Base case
        return 0
    else:               # Recursive case
        return arr[0] + list_sum(arr[1:])

print(list_sum([1, 2, 3, 4]))  # 10
```

---

# 🧠 How to Easily Understand & Code Recursion

✅ Steps:

1. **Identify the problem** → Can I break it into smaller versions of itself?
2. **Define base case** → Smallest possible input that I know the answer for.
3. **Define recursive case** → Function calls itself with smaller input.
4. **Combine results** → Build up the solution.

👉 Trick: Solve **one smaller case on paper first**, then generalize.

---

# ⚠️ Common Mistakes

* Forgetting the **base case** → leads to infinite recursion.
* Making recursion too **deep** → Python has recursion depth limits (\~1000 calls).
* Using recursion for simple loops unnecessarily (iteration is often faster).

---

# ✅ When to Use Recursion

* Problems with **self-similar structure**:

  * Factorials, Fibonacci
  * Tree/graph traversal 🌳
  * Divide & conquer algorithms (Merge Sort, Quick Sort)
  * Searching in nested structures (JSON, directories)
