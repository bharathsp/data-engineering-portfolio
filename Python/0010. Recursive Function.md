# ğŸ”„ **What is a Recursive Function?**

* A **recursive function** is a function that **calls itself** to solve a smaller version of the same problem.
* It keeps breaking the problem down until it hits a **base case** (stopping condition).

ğŸ‘‰ Two key parts of recursion:

1. **Base Case** â†’ when to stop (prevents infinite loops).
2. **Recursive Case** â†’ when the function calls itself with a smaller input.

---

# ğŸ–¼ï¸ Analogy

Imagine **Russian nesting dolls ğŸ**:

* Each doll contains a smaller one inside.
* You keep opening until you reach the smallest doll (base case).
* Then you â€œstack them back upâ€ (returning results).

---

# ğŸ—ï¸ Example 1: Factorial

Factorial (n!) = n Ã— (n-1) Ã— (n-2) â€¦ Ã— 1

```python
def factorial(n):
    if n == 0 or n == 1:   # Base case
        return 1
    else:                  # Recursive case
        return n * factorial(n-1)

print(factorial(5))  # 120
```

â¡ï¸ Flow for `factorial(5)`:

```
5 * factorial(4)
   4 * factorial(3)
      3 * factorial(2)
         2 * factorial(1)
            1  (base case)
```

---

# ğŸ—ï¸ Example 2: Fibonacci Sequence

Fibonacci: 0, 1, 1, 2, 3, 5, 8, â€¦

```python
def fibonacci(n):
    if n == 0:      # Base case
        return 0
    elif n == 1:
        return 1
    else:           # Recursive case
        return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(6))  # 8
```

â¡ï¸ Flow:

```
fibonacci(6) â†’ fibonacci(5) + fibonacci(4)
```

â€¦and so on, until reaching 0 and 1.

---

# ğŸ—ï¸ Example 3: Sum of a List

```python
def list_sum(arr):
    if len(arr) == 0:   # Base case
        return 0
    else:               # Recursive case
        return arr[0] + list_sum(arr[1:])

print(list_sum([1, 2, 3, 4]))  # 10
```

---

# ğŸ§  How to Easily Understand & Code Recursion

âœ… Steps:

1. **Identify the problem** â†’ Can I break it into smaller versions of itself?
2. **Define base case** â†’ Smallest possible input that I know the answer for.
3. **Define recursive case** â†’ Function calls itself with smaller input.
4. **Combine results** â†’ Build up the solution.

ğŸ‘‰ Trick: Solve **one smaller case on paper first**, then generalize.

---

# âš ï¸ Common Mistakes

* Forgetting the **base case** â†’ leads to infinite recursion.
* Making recursion too **deep** â†’ Python has recursion depth limits (\~1000 calls).
* Using recursion for simple loops unnecessarily (iteration is often faster).

---

# âœ… When to Use Recursion

* Problems with **self-similar structure**:

  * Factorials, Fibonacci
  * Tree/graph traversal ğŸŒ³
  * Divide & conquer algorithms (Merge Sort, Quick Sort)
  * Searching in nested structures (JSON, directories)
