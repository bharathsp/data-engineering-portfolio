## **1Ô∏è‚É£ What are decorators in Python?**

A **decorator** is a **function that takes another function as input, adds extra functionality to it, and returns the modified function** ‚Äî without changing the original function‚Äôs code.

Think of it like **wrapping a gift**:

* The original gift (function) stays the same.
* The wrapper (decorator) adds beauty or extra protection.

---

## **2Ô∏è‚É£ How does it work?**

A decorator:

1. Takes a function as an argument.
2. Defines a wrapper function that adds something before/after the original function runs.
3. Returns the wrapper function.

This is possible in Python because **functions are first-class citizens** ‚Äî they can be passed around as arguments and returned from other functions.

---

## **3Ô∏è‚É£ Syntax**

```python
@decorator_name
def my_function():
    ...
```

The `@decorator_name` is **just shorthand** for:

```python
my_function = decorator_name(my_function)
```

---

## **4Ô∏è‚É£ Example**

```python
# Step 1: Define a decorator
def greet_decorator(func):
    def wrapper():
        print("üëã Hello! Before the function runs...")
        func()
        print("‚úÖ After the function runs...")
    return wrapper

# Step 2: Use @ to apply decorator
@greet_decorator
def say_name():
    print("My name is Python!")

# Step 3: Call the decorated function
say_name()
```

**Output:**

```
üëã Hello! Before the function runs...
My name is Python!
‚úÖ After the function runs...
```

---

## **5Ô∏è‚É£ When to use decorators?**

* **Logging** (track function calls)
* **Authentication/Authorization** (check if a user is logged in)
* **Timing/Performance measurement** (calculate execution time)
* **Caching results** for expensive operations
* **Validation** (check inputs before running a function)

---

## **6Ô∏è‚É£ Real-life analogy**

Imagine you have **a chef (function)** cooking meals.
You hire **a waiter (decorator)** who:

* Greets the guest before serving food.
* Cleans up after the food is served.
  The chef still cooks the same dish, but the experience is enhanced.

---

## **7Ô∏è‚É£ Real-life Python Example ‚Äì Logging**

```python
import time

def log_execution_time(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)  # run the function
        end = time.time()
        print(f"‚è± {func.__name__} took {end - start:.4f} seconds to execute.")
        return result
    return wrapper

@log_execution_time
def process_data():
    time.sleep(1)  # simulating heavy work
    print("üìä Data processed!")

process_data()
```

**Output:**

```
üìä Data processed!
‚è± process_data took 1.0005 seconds to execute.
```

---

# **Built-in decorators in Python** 

---

### 1. **@staticmethod**

* Used inside classes.
* Defines a method that does not require access to the instance (`self`) or the class (`cls`).
* Behaves like a normal function but placed inside a class for logical grouping.

```python
class Example:
    @staticmethod
    def greet(name):
        return f"Hello, {name}"

print(Example.greet("Bharath"))  # ‚úÖ Hello, Bharath
```

---

### 2. **@classmethod**

* Also used inside classes.
* The method receives the **class itself** (`cls`) as the first argument instead of an instance (`self`).

```python
class Example:
    count = 0

    @classmethod
    def increment(cls):
        cls.count += 1
        return cls.count

print(Example.increment())  # ‚úÖ 1
print(Example.increment())  # ‚úÖ 2
```

---

### 3. **@property**

* Turns a **method** into a **read-only attribute**.
* Often used for getter methods.

```python
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def area(self):
        return 3.14 * self._radius ** 2

c = Circle(5)
print(c.area)  # ‚úÖ 78.5 (no need to call as method)
```

üëâ Variants:

* `@<property>.setter` ‚Üí defines a setter for the property.
* `@<property>.deleter` ‚Üí defines a deleter for the property.

---

### 4. **@functools.lru_cache (from functools module)**

* Not strictly "built-in" at language level, but part of the **standard library**.
* Caches function results for faster repeated calls.

```python
from functools import lru_cache

@lru_cache(maxsize=None)
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(30))  # ‚úÖ 832040 (computed fast with caching)
```

---

### 5. **@functools.wraps**

* A helper decorator used when **writing custom decorators**.
* Preserves the original function‚Äôs metadata (like name, docstring) when wrapped.

```python
from functools import wraps

def my_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print("Before function call")
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def greet():
    """Greets the user"""
    print("Hello!")

print(greet.__name__)   # ‚úÖ greet (without @wraps it would show 'wrapper')
```
