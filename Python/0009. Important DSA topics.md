## **1. Arrays / Lists**

* **Concept:** Sequential collection of items, indexed.
* **Key Problems:** Reverse array, rotate array, two-sum, subarray sums.

```python
# Example: Reverse array
arr = [1, 2, 3, 4, 5]
arr.reverse()
print(arr)  # [5, 4, 3, 2, 1]
```

---

## **2. Strings**

* **Concept:** Immutable sequences of characters.
* **Key Problems:** Palindrome check, anagram check, substring search.

```python
# Palindrome check
s = "madam"
print(s == s[::-1])  # True
```

---

## **3. Hashing (Dictionary & Set)**

* **Concept:** Store key-value pairs or unique values for O(1) lookups.
* **Key Problems:** Two-sum, frequency counting.

```python
# Frequency count
from collections import Counter
print(Counter("banana"))  # {'b':1, 'a':3, 'n':2}
```

---

## **4. Linked List**

* **Concept:** Node-based sequential structure.
* **Key Problems:** Reverse linked list, detect cycle, merge lists.

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
```

---

## **5. Stack & Queue**

* **Concept:**

  * Stack → LIFO (Last In First Out)
  * Queue → FIFO (First In First Out)
* **Key Problems:** Balanced parentheses, sliding window.

```python
# Stack example
stack = []
stack.append(1)
stack.append(2)
print(stack.pop())  # 2
```

---

## **6. Recursion**

* **Concept:** Function calling itself until base condition.
* **Key Problems:** Factorial, Fibonacci, backtracking.

```python
def factorial(n):
    return 1 if n == 0 else n * factorial(n-1)
```

---

## **7. Sorting**

* **Concept:** Arranging elements in order.
* **Key Problems:** Merge sort, quicksort, counting sort.

```python
arr = [4, 2, 1, 3]
print(sorted(arr))  # [1, 2, 3, 4]
```

---

## **8. Searching**

* **Concept:** Finding an element.
* **Key Problems:** Binary search, search in rotated array.

```python
# Binary Search
def binary_search(arr, x):
    l, r = 0, len(arr)-1
    while l <= r:
        mid = (l+r)//2
        if arr[mid] == x:
            return mid
        elif arr[mid] < x:
            l = mid+1
        else:
            r = mid-1
    return -1
```

---

## **9. Dynamic Programming**

* **Concept:** Breaking problems into overlapping subproblems.
* **Key Problems:** Fibonacci, knapsack, longest common subsequence.

```python
# Fibonacci DP
dp = [0, 1]
for i in range(2, 10):
    dp.append(dp[i-1] + dp[i-2])
```

---

## **10. Graphs**

* **Concept:** Nodes (vertices) and edges.
* **Key Problems:** BFS, DFS, shortest path.

```python
# BFS
from collections import deque
graph = {1:[2,3], 2:[4], 3:[4], 4:[]}
visited = set()
queue = deque([1])
while queue:
    node = queue.popleft()
    if node not in visited:
        print(node)
        visited.add(node)
        queue.extend(graph[node])
```

---

## **11. Heaps / Priority Queue**

* **Concept:** Special tree for min/max priority retrieval.
* **Key Problems:** K largest elements, heap sort.

```python
import heapq
nums = [5,1,8,2]
heapq.heapify(nums)
print(heapq.heappop(nums))  # 1
```

---

## **12. Trees**

* **Concept:** Hierarchical data.
* **Key Problems:** Traversals (Inorder, Preorder, Postorder), BST operations.

```python
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
```

---

## **13. Bit Manipulation**

* **Concept:** Work at binary level.
* **Key Problems:** Single number, power of two check.

```python
n = 8
print(n & (n-1) == 0)  # True (power of 2)
```

---

✅ **Tip for Interviews:**
Focus on **patterns** like:

* Sliding Window
* Two Pointers
* Divide & Conquer
* Greedy Algorithms
* Backtracking

---
