# Class and Object

## 📚 **Definition**

A **class** in Python is a **blueprint** for creating objects.
It defines the **attributes** (data) and **methods** (functions) that the objects will have.

An **object** is an instance of a class. It is a fundamental building block that encapsulates both data (attributes or properties) and the functions (methods or behaviors) that operate on that data.

---

## 🐍 **Python Syntax**

```python
# Defining a class
class Car:
    def __init__(self, brand, model):
        self.brand = brand   # attribute
        self.model = model   # attribute
    
    def start_engine(self):
        print(f"{self.brand} {self.model}'s engine started!")

# Creating an object
my_car = Car("Tesla", "Model S")

# Accessing attributes and methods
print(my_car.brand)   # Output: Tesla
my_car.start_engine() # Output: Tesla Model S's engine started!
```

---

## 🛠 **Syntax Breakdown**

* `class ClassName:` → Defines a class.
* `__init__()` → **Constructor** method, runs when you create an object.
* `self` → Refers to the **current object instance**.
* `self.attribute` → Variables unique to each object.
* Methods → Functions inside a class.

---

## 🏠 **Real-Life Analogy**

Think of a **class** like a **house blueprint**:

* The blueprint (**class**) describes **what the house will have** (rooms, doors, windows).
* Each built house (**object**) will have **its own actual features** (color, size, furniture).
* You can build many houses from **one blueprint**.

---

## 🎯 **With Icons**

📝 **Class** → The **blueprint** for objects
🏗 **Object** → The **actual item** built from the blueprint
📦 **Attributes** → The **data** stored in the object
⚙ **Methods** → The **actions** the object can perform

Example mapping for our `Car` class:

| Icon | Concept   | Example                                |
| ---- | --------- | -------------------------------------- |
| 📝   | Class     | `Car` blueprint                        |
| 🏗   | Object    | `my_car = Car("Tesla", "Model S")`     |
| 📦   | Attribute | `brand = "Tesla"`, `model = "Model S"` |
| ⚙    | Method    | `start_engine()`                       |

---

Alright — let’s make **Encapsulation** easy to understand with Python examples, a real-life analogy, and icons.

---

# Encapsulation

## 🔒 **Definition**

**Encapsulation** is the OOP concept of **bundling** data (attributes) and methods (functions) inside a single unit (class) and **restricting direct access** to the data to protect it.
This ensures that the object’s internal state can only be changed through controlled methods.

---

## 🐍 **Python Example**

```python
class BankAccount:
    def __init__(self, account_holder, balance):
        self.account_holder = account_holder   # public attribute
        self.__balance = balance               # private attribute (name mangling)

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print(f"Deposited ₹{amount}. New balance: ₹{self.__balance}")
        else:
            print("Deposit amount must be positive.")

    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            print(f"Withdrew ₹{amount}. New balance: ₹{self.__balance}")
        else:
            print("Invalid withdrawal amount.")

    def get_balance(self):
        return self.__balance

# Usage
account = BankAccount("Bharath", 5000)
account.deposit(2000)
account.withdraw(1000)

# Trying to access private variable directly (will fail)
# print(account.__balance)  # ❌ AttributeError
print(account.get_balance()) # ✅ Access through method
```

---

## 🛠 **Syntax Highlights**

* `self.__balance` → **Private** variable (double underscore makes it hard to access directly).
* Methods like `deposit()` and `withdraw()` control how the balance changes.
* You **never** directly change `__balance` from outside — you use methods.

---

## 🏦 **Real-Life Analogy**

Think of a **bank account**:

* You **can’t** just open the vault and grab your money.
* You must use **secure methods** like ATMs or withdrawal slips.
* The **vault (data)** is protected, and the **bank processes (methods)** control access.

---

## 🎯 **With Icons**

| Icon | Concept           | Example                                                      |
| ---- | ----------------- | ------------------------------------------------------------ |
| 🛡   | Protection        | Private variable `__balance`                                 |
| 🔑   | Controlled Access | `deposit()` and `withdraw()` methods                         |
| 📦   | Bundling          | Data (`__balance`) + Methods (transactions) inside one class |
| 🚫   | Restricted Access | Cannot directly modify `__balance`                           |

---

# Abstraction


## 🎭 **Definition**

**Abstraction** is the concept of **hiding the complex internal details** of how something works and **exposing only the necessary functionality** to the user.

In Python, abstraction is often implemented using:

* **Abstract Classes** (`abc` module)
* **Interfaces** (conceptually, though Python uses abstract base classes instead)

---

## 🐍 **Python Example**

```python
from abc import ABC, abstractmethod

# Abstract class
class Vehicle(ABC):
    @abstractmethod
    def start_engine(self):
        pass

    @abstractmethod
    def stop_engine(self):
        pass

# Concrete class
class Car(Vehicle):
    def start_engine(self):
        print("Car engine started 🚗")

    def stop_engine(self):
        print("Car engine stopped 🛑")

# Usage
my_car = Car()
my_car.start_engine()
my_car.stop_engine()
```

**Explanation:**

* `Vehicle` → **Abstract class** (cannot be instantiated).
* `@abstractmethod` → Forces subclasses to implement the method.
* `Car` → Provides actual implementation.
* The **user** only calls `start_engine()` / `stop_engine()` without worrying about **how** they work internally.

---

## 🏠 **Real-Life Analogy**

Think of **driving a car**:

* You press the **start button** to start the engine.
* You don’t need to know about:

  * Fuel injection
  * Spark plugs
  * Ignition system
* The **complex details are hidden**; you just interact with simple controls.

---

## 🎯 **With Icons**

| Icon | Concept         | Example                                           |
| ---- | --------------- | ------------------------------------------------- |
| 🎭   | Hide Details    | Internal engine mechanics hidden                  |
| 🎮   | Simple Controls | `start_engine()` / `stop_engine()` methods        |
| 🛠   | Implementation  | Provided in concrete class (`Car`)                |
| 🚗   | Real Usage      | You just “drive” without knowing internal working |

---

# Inheritance

## 🌳 **Definition**

**Inheritance** is the OOP concept where a class (**child/subclass**) can **reuse and extend** the properties and methods of another class (**parent/superclass**).
It promotes **code reusability** and **hierarchical relationships** between classes.

---

## 🐍 **Python Example**

```python
# Parent class
class Vehicle:
    def __init__(self, brand):
        self.brand = brand

    def start_engine(self):
        print(f"{self.brand}'s engine started 🚀")

# Child class
class Car(Vehicle):
    def __init__(self, brand, model):
        super().__init__(brand)  # Call parent constructor
        self.model = model

    def display_info(self):
        print(f"Car: {self.brand} {self.model}")

# Another child class
class Bike(Vehicle):
    def ride(self):
        print(f"Riding the {self.brand} bike 🏍")

# Usage
my_car = Car("Tesla", "Model S")
my_car.start_engine()  # Inherited method
my_car.display_info()  # Child class method

my_bike = Bike("Yamaha")
my_bike.start_engine() # Inherited method
my_bike.ride()         # Child class method
```

**Key points:**

* `Car` and `Bike` **inherit** from `Vehicle`.
* `super().__init__()` calls the parent constructor.
* Child classes can **reuse** or **override** parent methods.

---

## 🏠 **Real-Life Analogy**

Think of **family traits**:

* **Parent**: Has certain features (eye color, height, surname).
* **Child**: Inherits those traits but can also have new features (hobbies, skills).
* Some traits can be **modified** (method overriding).

---

## 🎯 **With Icons**

| Icon | Concept        | Example                                            |
| ---- | -------------- | -------------------------------------------------- |
| 🧬   | Parent Traits  | `start_engine()` from `Vehicle`                    |
| 👶   | Child Inherits | `Car` and `Bike` classes                           |
| ➕    | Extra Features | `display_info()` in `Car`, `ride()` in `Bike`      |
| ✏    | Override       | Change `start_engine()` in a child class if needed |

---

## 📌 **Types of Inheritance in Python**

1. **Single** – One parent, one child.
2. **Multiple** – Child inherits from multiple parents.
3. **Multilevel** – Parent → Child → Grandchild.
4. **Hierarchical** – One parent, multiple children.
5. **Hybrid** – Combination of the above.

---

# Polymorphism

## 🎭 **Definition**

**Polymorphism** means **“many forms”** — the ability to use the **same method name** or operation but have **different behaviors** depending on the object or data type.

In OOP, it allows:

* **Same interface** → **Different implementations**.
* Writing code that works with **different types of objects** without modification.

---

## 🐍 **Python Example – Method Overriding (Runtime Polymorphism)**

```python
class Vehicle:
    def start_engine(self):
        print("Starting a generic vehicle engine 🚀")

class Car(Vehicle):
    def start_engine(self):
        print("Starting a car engine 🚗")

class Bike(Vehicle):
    def start_engine(self):
        print("Starting a bike engine 🏍")

# Polymorphism in action
vehicles = [Car(), Bike(), Vehicle()]

for v in vehicles:
    v.start_engine()  # Same method name, different behavior
```

---

## 🐍 **Python Example – Built-in Polymorphism**

```python
print(len("Hello"))      # Works on strings → Output: 5
print(len([1, 2, 3, 4])) # Works on lists → Output: 4
print(len({"a": 1}))     # Works on dictionaries → Output: 1
```

Same function `len()` behaves differently depending on the type of object.

---

## 🏠 **Real-Life Analogy**

Think of the action **“Draw”**:

* 🖊 **Pen** draws ink on paper.
* 🖌 **Paintbrush** draws color on canvas.
* 💻 **Graphics tablet** draws pixels on screen.

The **command is the same**, but the **result is different** depending on the tool.

---

## 🎯 **With Icons**

| Icon | Concept               | Example                                        |
| ---- | --------------------- | ---------------------------------------------- |
| 🎭   | Many Forms            | Same `start_engine()` method works differently |
| 🔄   | Method Overriding     | `Car` and `Bike` redefine the method           |
| 🛠   | Common Interface      | All inherit from `Vehicle`                     |
| 📦   | Built-in Polymorphism | `len()` works on multiple data types           |

---

## 📌 **Two Main Types of Polymorphism in Python**

1. **Compile-time** (Method Overloading) – Python doesn’t truly support this like Java, but can simulate it with default arguments or `*args`.
2. **Runtime** (Method Overriding) – Common in Python; decided when the program runs.

---

# Method Overloading

## 📚 **Definition**

**Method Overloading** means having **multiple methods with the same name but different parameter lists** (number or type of parameters).

* In **Java/C++** → You can have multiple versions of a method in the same class.
* In **Python** → This is not directly supported, because the **last defined method** with the same name will overwrite previous ones.
* However, Python can **simulate** overloading using **default arguments**, `*args`, or type checking.

---

## 🐍 **Example – Simulated Method Overloading**

```python
class Calculator:
    def add(self, a=None, b=None, c=None):
        if a is not None and b is not None and c is not None:
            return a + b + c
        elif a is not None and b is not None:
            return a + b
        elif a is not None:
            return a
        else:
            return 0

calc = Calculator()
print(calc.add(5, 10))       # 15
print(calc.add(5, 10, 15))   # 30
print(calc.add(5))           # 5
print(calc.add())            # 0
```

**How it works:**

* Instead of writing multiple versions of `add()`, we handle all variations **inside one method** using conditional checks.

---

## 🛠 **Using `*args` for Flexible Overloading**

```python
class Calculator:
    def add(self, *numbers):
        return sum(numbers)

calc = Calculator()
print(calc.add(1, 2))        # 3
print(calc.add(1, 2, 3))     # 6
print(calc.add(1, 2, 3, 4))  # 10
```

**Here:**

* `*numbers` can take any number of arguments.
* `sum(numbers)` adds them all.

---

## 🏠 **Real-Life Analogy**

Think of a **Swiss Army Knife**:

* One knife can **cut**.
* One can **open bottles**.
* One can **unscrew bolts**.
  Same **tool name**, but works differently depending on **how and what you use it for**.

---

## 🎯 **With Icons**

| Icon | Concept                       | Example                                               |
| ---- | ----------------------------- | ----------------------------------------------------- |
| 🛠   | Same Name, Different Behavior | `add()` works for 2, 3, or more numbers               |
| 📦   | Flexible Parameters           | Default values, `*args`                               |
| 🔄   | Simulated in Python           | Python doesn’t truly allow multiple same-name methods |

---

# Method Overriding

## 📚 **Definition**

**Method Overriding** happens when a **child class** provides a **new implementation** for a method that already exists in its **parent class**.

* The **method name** and **parameters** remain the same.
* The **child’s method** replaces the parent’s method when called on a child object.

---

## 🐍 **Python Example**

```python
class Vehicle:
    def start_engine(self):
        print("Starting a generic vehicle engine 🚀")

class Car(Vehicle):
    def start_engine(self):  # Overriding
        print("Starting a car engine 🚗")

class Bike(Vehicle):
    def start_engine(self):  # Overriding
        print("Starting a bike engine 🏍")

# Usage
vehicle = Vehicle()
vehicle.start_engine()  # Output: Starting a generic vehicle engine 🚀

car = Car()
car.start_engine()      # Output: Starting a car engine 🚗

bike = Bike()
bike.start_engine()     # Output: Starting a bike engine 🏍
```

---

## 🛠 **Key Points**

* **Same name + same parameters** = method overriding.
* Happens in **inheritance** only.
* Enables **runtime polymorphism** — the method to call is decided at runtime.
* You can still call the parent’s method using `super()`.

---

## 🔄 **Calling Parent Method**

```python
class Car(Vehicle):
    def start_engine(self):
        super().start_engine()  # Call parent version
        print("Car engine started with extra checks ✅")
```

---

## 🏠 **Real-Life Analogy**

Imagine a **company policy**:

* Parent company: “Work starts at 9 AM.”
* Child branch: “Work starts at 10 AM because of local conditions.”
  Same **rule name**, but **different implementation** in each branch.

---

## 🎯 **With Icons**

| Icon | Concept              | Example                                       |
| ---- | -------------------- | --------------------------------------------- |
| 🔄   | Override             | Child changes parent method behavior          |
| 🧬   | Inheritance Required | Works only in a parent-child relationship     |
| ⏳    | Runtime Decision     | Python decides which method to run at runtime |
| 📞   | `super()`            | Call parent method from child                 |

---

# Constructors and Destructors

## 🏗 **Constructor**

### 📚 **Definition**

A **constructor** is a special method in Python (`__init__`) that **runs automatically** when an object is created.
It is used to **initialize** the object’s attributes.

---

### 🐍 **Python Constructor Example**

```python
class Car:
    def __init__(self, brand, model):  # Constructor
        self.brand = brand
        self.model = model
        print(f"Car object created: {self.brand} {self.model}")

# Object creation automatically calls the constructor
my_car = Car("Tesla", "Model S")
```

**Output:**

```
Car object created: Tesla Model S
```

---

## 💣 **Destructor**

### 📚 **Definition**

A **destructor** is a special method in Python (`__del__`) that **runs automatically** when an object is about to be destroyed (garbage collected).
It is used for **cleanup tasks** like closing files or releasing resources.

---

### 🐍 **Python Destructor Example**

```python
class Car:
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model
        print(f"Car object created: {self.brand} {self.model}")

    def __del__(self):  # Destructor
        print(f"Car object destroyed: {self.brand} {self.model}")

# Creating and deleting an object
my_car = Car("Tesla", "Model S")
del my_car  # Manually delete
```

**Output:**

```
Car object created: Tesla Model S
Car object destroyed: Tesla Model S
```

---

## 🏠 **Real-Life Analogy**

* **Constructor (`__init__`)** → Like **moving into a new house** — you unpack and arrange everything when you arrive.
* **Destructor (`__del__`)** → Like **moving out** — you pack up and clean before leaving.

---

## 🎯 **With Icons**

| Icon | Concept        | Example                              |
| ---- | -------------- | ------------------------------------ |
| 🏗   | Constructor    | `__init__` sets initial object state |
| 🛠   | Initialization | Assigning `brand`, `model`           |
| 💣   | Destructor     | `__del__` cleans up before deletion  |
| 🧹   | Cleanup        | Closing files, releasing memory      |

---

# Access Modifiers

## 🔐 **Definition**

Access modifiers **control the visibility** of variables and methods in a class — i.e., whether they can be accessed from **outside** the class.

In Python, access control is mostly **convention-based**, not enforced like in Java/C++.

---

## 📌 **Types of Access Modifiers in Python**

| Modifier      | Syntax       | Access Scope                                      |
| ------------- | ------------ | ------------------------------------------------- |
| **Public**    | `variable`   | Accessible from anywhere                          |
| **Protected** | `_variable`  | Accessible within class & subclasses (convention) |
| **Private**   | `__variable` | Accessible only within the class (name mangling)  |

---

## 🐍 **Python Example**

```python
class Person:
    def __init__(self, name, age, salary):
        self.name = name          # Public
        self._age = age           # Protected (by convention)
        self.__salary = salary    # Private

    def show_salary(self):
        print(f"Salary: ₹{self.__salary}")

person = Person("Bharath", 30, 50000)

# Public - Accessible
print(person.name)  # ✅

# Protected - Accessible but should be avoided directly
print(person._age)  # ⚠ (Not recommended)

# Private - Direct access will fail
# print(person.__salary)  # ❌ AttributeError

# Access private data through a method
person.show_salary()  # ✅ Salary: ₹50000
```

---

## 🛠 **How Private Works (Name Mangling)**

Private members are internally renamed:

```python
print(person._Person__salary)  # Works but breaks encapsulation
```

---

## 🏠 **Real-Life Analogy**

Think of a **company**:

* **Public** (Reception) → Anyone can walk in.
* **Protected** (Staff Room) → Only employees should enter, but not enforced by security guard.
* **Private** (CEO’s Office) → Strict access, only the CEO can enter.

---

## 🎯 **With Icons**

| Icon | Modifier  | Example    |
| ---- | --------- | ---------- |
| 🌍   | Public    | `name`     |
| 🛡   | Protected | `_age`     |
| 🔒   | Private   | `__salary` |

---

