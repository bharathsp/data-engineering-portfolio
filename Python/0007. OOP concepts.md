# Class and Object

## ðŸ“š **Definition**

A **class** in Python is a **blueprint** for creating objects.
It defines the **attributes** (data) and **methods** (functions) that the objects will have.

An **object** is an instance of a class. It is a fundamental building block that encapsulates both data (attributes or properties) and the functions (methods or behaviors) that operate on that data.

---

## ðŸ **Python Syntax**

```python
# Defining a class
class Car:
    def __init__(self, brand, model):
        self.brand = brand   # attribute
        self.model = model   # attribute
    
    def start_engine(self):
        print(f"{self.brand} {self.model}'s engine started!")

# Creating an object
my_car = Car("Tesla", "Model S")

# Accessing attributes and methods
print(my_car.brand)   # Output: Tesla
my_car.start_engine() # Output: Tesla Model S's engine started!
```

---

## ðŸ›  **Syntax Breakdown**

* `class ClassName:` â†’ Defines a class.
* `__init__()` â†’ **Constructor** method, runs when you create an object.
* `self` â†’ Refers to the **current object instance**.
* `self.attribute` â†’ Variables unique to each object.
* Methods â†’ Functions inside a class.

---

## ðŸ  **Real-Life Analogy**

Think of a **class** like a **house blueprint**:

* The blueprint (**class**) describes **what the house will have** (rooms, doors, windows).
* Each built house (**object**) will have **its own actual features** (color, size, furniture).
* You can build many houses from **one blueprint**.

---

## ðŸŽ¯ **With Icons**

ðŸ“ **Class** â†’ The **blueprint** for objects
ðŸ— **Object** â†’ The **actual item** built from the blueprint
ðŸ“¦ **Attributes** â†’ The **data** stored in the object
âš™ **Methods** â†’ The **actions** the object can perform

Example mapping for our `Car` class:

| Icon | Concept   | Example                                |
| ---- | --------- | -------------------------------------- |
| ðŸ“   | Class     | `Car` blueprint                        |
| ðŸ—   | Object    | `my_car = Car("Tesla", "Model S")`     |
| ðŸ“¦   | Attribute | `brand = "Tesla"`, `model = "Model S"` |
| âš™    | Method    | `start_engine()`                       |

---

Alright â€” letâ€™s make **Encapsulation** easy to understand with Python examples, a real-life analogy, and icons.

---

# Encapsulation

## ðŸ”’ **Definition**

**Encapsulation** is the OOP concept of **bundling** data (attributes) and methods (functions) inside a single unit (class) and **restricting direct access** to the data to protect it.
This ensures that the objectâ€™s internal state can only be changed through controlled methods.

---

## ðŸ **Python Example**

```python
class BankAccount:
    def __init__(self, account_holder, balance):
        self.account_holder = account_holder   # public attribute
        self.__balance = balance               # private attribute (name mangling)

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print(f"Deposited â‚¹{amount}. New balance: â‚¹{self.__balance}")
        else:
            print("Deposit amount must be positive.")

    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            print(f"Withdrew â‚¹{amount}. New balance: â‚¹{self.__balance}")
        else:
            print("Invalid withdrawal amount.")

    def get_balance(self):
        return self.__balance

# Usage
account = BankAccount("Bharath", 5000)
account.deposit(2000)
account.withdraw(1000)

# Trying to access private variable directly (will fail)
# print(account.__balance)  # âŒ AttributeError
print(account.get_balance()) # âœ… Access through method
```

---

## ðŸ›  **Syntax Highlights**

* `self.__balance` â†’ **Private** variable (double underscore makes it hard to access directly).
* Methods like `deposit()` and `withdraw()` control how the balance changes.
* You **never** directly change `__balance` from outside â€” you use methods.

---

## ðŸ¦ **Real-Life Analogy**

Think of a **bank account**:

* You **canâ€™t** just open the vault and grab your money.
* You must use **secure methods** like ATMs or withdrawal slips.
* The **vault (data)** is protected, and the **bank processes (methods)** control access.

---

## ðŸŽ¯ **With Icons**

| Icon | Concept           | Example                                                      |
| ---- | ----------------- | ------------------------------------------------------------ |
| ðŸ›¡   | Protection        | Private variable `__balance`                                 |
| ðŸ”‘   | Controlled Access | `deposit()` and `withdraw()` methods                         |
| ðŸ“¦   | Bundling          | Data (`__balance`) + Methods (transactions) inside one class |
| ðŸš«   | Restricted Access | Cannot directly modify `__balance`                           |

---

# Abstraction


## ðŸŽ­ **Definition**

**Abstraction** is the concept of **hiding the complex internal details** of how something works and **exposing only the necessary functionality** to the user.

In Python, abstraction is often implemented using:

* **Abstract Classes** (`abc` module)
* **Interfaces** (conceptually, though Python uses abstract base classes instead)

---

## ðŸ **Python Example**

```python
from abc import ABC, abstractmethod

# Abstract class
class Vehicle(ABC):
    @abstractmethod
    def start_engine(self):
        pass

    @abstractmethod
    def stop_engine(self):
        pass

# Concrete class
class Car(Vehicle):
    def start_engine(self):
        print("Car engine started ðŸš—")

    def stop_engine(self):
        print("Car engine stopped ðŸ›‘")

# Usage
my_car = Car()
my_car.start_engine()
my_car.stop_engine()
```

**Explanation:**

* `Vehicle` â†’ **Abstract class** (cannot be instantiated).
* `@abstractmethod` â†’ Forces subclasses to implement the method.
* `Car` â†’ Provides actual implementation.
* The **user** only calls `start_engine()` / `stop_engine()` without worrying about **how** they work internally.

---

## ðŸ  **Real-Life Analogy**

Think of **driving a car**:

* You press the **start button** to start the engine.
* You donâ€™t need to know about:

  * Fuel injection
  * Spark plugs
  * Ignition system
* The **complex details are hidden**; you just interact with simple controls.

---

## ðŸŽ¯ **With Icons**

| Icon | Concept         | Example                                           |
| ---- | --------------- | ------------------------------------------------- |
| ðŸŽ­   | Hide Details    | Internal engine mechanics hidden                  |
| ðŸŽ®   | Simple Controls | `start_engine()` / `stop_engine()` methods        |
| ðŸ›    | Implementation  | Provided in concrete class (`Car`)                |
| ðŸš—   | Real Usage      | You just â€œdriveâ€ without knowing internal working |

---

# Inheritance

## ðŸŒ³ **Definition**

**Inheritance** is the OOP concept where a class (**child/subclass**) can **reuse and extend** the properties and methods of another class (**parent/superclass**).
It promotes **code reusability** and **hierarchical relationships** between classes.

---

## ðŸ **Python Example**

```python
# Parent class
class Vehicle:
    def __init__(self, brand):
        self.brand = brand

    def start_engine(self):
        print(f"{self.brand}'s engine started ðŸš€")

# Child class
class Car(Vehicle):
    def __init__(self, brand, model):
        super().__init__(brand)  # Call parent constructor
        self.model = model

    def display_info(self):
        print(f"Car: {self.brand} {self.model}")

# Another child class
class Bike(Vehicle):
    def ride(self):
        print(f"Riding the {self.brand} bike ðŸ")

# Usage
my_car = Car("Tesla", "Model S")
my_car.start_engine()  # Inherited method
my_car.display_info()  # Child class method

my_bike = Bike("Yamaha")
my_bike.start_engine() # Inherited method
my_bike.ride()         # Child class method
```

**Key points:**

* `Car` and `Bike` **inherit** from `Vehicle`.
* `super().__init__()` calls the parent constructor.
* Child classes can **reuse** or **override** parent methods.

---

## ðŸ  **Real-Life Analogy**

Think of **family traits**:

* **Parent**: Has certain features (eye color, height, surname).
* **Child**: Inherits those traits but can also have new features (hobbies, skills).
* Some traits can be **modified** (method overriding).

---

## ðŸŽ¯ **With Icons**

| Icon | Concept        | Example                                            |
| ---- | -------------- | -------------------------------------------------- |
| ðŸ§¬   | Parent Traits  | `start_engine()` from `Vehicle`                    |
| ðŸ‘¶   | Child Inherits | `Car` and `Bike` classes                           |
| âž•    | Extra Features | `display_info()` in `Car`, `ride()` in `Bike`      |
| âœ    | Override       | Change `start_engine()` in a child class if needed |

---

## ðŸ“Œ **Types of Inheritance in Python**

1. **Single** â€“ One parent, one child.
2. **Multiple** â€“ Child inherits from multiple parents.
3. **Multilevel** â€“ Parent â†’ Child â†’ Grandchild.
4. **Hierarchical** â€“ One parent, multiple children.
5. **Hybrid** â€“ Combination of the above.

---

# Polymorphism

## ðŸŽ­ **Definition**

**Polymorphism** means **â€œmany formsâ€** â€” the ability to use the **same method name** or operation but have **different behaviors** depending on the object or data type.

In OOP, it allows:

* **Same interface** â†’ **Different implementations**.
* Writing code that works with **different types of objects** without modification.

---

## ðŸ **Python Example â€“ Method Overriding (Runtime Polymorphism)**

```python
class Vehicle:
    def start_engine(self):
        print("Starting a generic vehicle engine ðŸš€")

class Car(Vehicle):
    def start_engine(self):
        print("Starting a car engine ðŸš—")

class Bike(Vehicle):
    def start_engine(self):
        print("Starting a bike engine ðŸ")

# Polymorphism in action
vehicles = [Car(), Bike(), Vehicle()]

for v in vehicles:
    v.start_engine()  # Same method name, different behavior
```

---

## ðŸ **Python Example â€“ Built-in Polymorphism**

```python
print(len("Hello"))      # Works on strings â†’ Output: 5
print(len([1, 2, 3, 4])) # Works on lists â†’ Output: 4
print(len({"a": 1}))     # Works on dictionaries â†’ Output: 1
```

Same function `len()` behaves differently depending on the type of object.

---

## ðŸ  **Real-Life Analogy**

Think of the action **â€œDrawâ€**:

* ðŸ–Š **Pen** draws ink on paper.
* ðŸ–Œ **Paintbrush** draws color on canvas.
* ðŸ’» **Graphics tablet** draws pixels on screen.

The **command is the same**, but the **result is different** depending on the tool.

---

## ðŸŽ¯ **With Icons**

| Icon | Concept               | Example                                        |
| ---- | --------------------- | ---------------------------------------------- |
| ðŸŽ­   | Many Forms            | Same `start_engine()` method works differently |
| ðŸ”„   | Method Overriding     | `Car` and `Bike` redefine the method           |
| ðŸ›    | Common Interface      | All inherit from `Vehicle`                     |
| ðŸ“¦   | Built-in Polymorphism | `len()` works on multiple data types           |

---

## ðŸ“Œ **Two Main Types of Polymorphism in Python**

1. **Compile-time** (Method Overloading) â€“ Python doesnâ€™t truly support this like Java, but can simulate it with default arguments or `*args`.
2. **Runtime** (Method Overriding) â€“ Common in Python; decided when the program runs.

---

# Method Overloading

## ðŸ“š **Definition**

**Method Overloading** means having **multiple methods with the same name but different parameter lists** (number or type of parameters).

* In **Java/C++** â†’ You can have multiple versions of a method in the same class.
* In **Python** â†’ This is not directly supported, because the **last defined method** with the same name will overwrite previous ones.
* However, Python can **simulate** overloading using **default arguments**, `*args`, or type checking.

---

## ðŸ **Example â€“ Simulated Method Overloading**

```python
class Calculator:
    def add(self, a=None, b=None, c=None):
        if a is not None and b is not None and c is not None:
            return a + b + c
        elif a is not None and b is not None:
            return a + b
        elif a is not None:
            return a
        else:
            return 0

calc = Calculator()
print(calc.add(5, 10))       # 15
print(calc.add(5, 10, 15))   # 30
print(calc.add(5))           # 5
print(calc.add())            # 0
```

**How it works:**

* Instead of writing multiple versions of `add()`, we handle all variations **inside one method** using conditional checks.

---

## ðŸ›  **Using `*args` for Flexible Overloading**

```python
class Calculator:
    def add(self, *numbers):
        return sum(numbers)

calc = Calculator()
print(calc.add(1, 2))        # 3
print(calc.add(1, 2, 3))     # 6
print(calc.add(1, 2, 3, 4))  # 10
```

**Here:**

* `*numbers` can take any number of arguments.
* `sum(numbers)` adds them all.

---

## ðŸ  **Real-Life Analogy**

Think of a **Swiss Army Knife**:

* One knife can **cut**.
* One can **open bottles**.
* One can **unscrew bolts**.
  Same **tool name**, but works differently depending on **how and what you use it for**.

---

## ðŸŽ¯ **With Icons**

| Icon | Concept                       | Example                                               |
| ---- | ----------------------------- | ----------------------------------------------------- |
| ðŸ›    | Same Name, Different Behavior | `add()` works for 2, 3, or more numbers               |
| ðŸ“¦   | Flexible Parameters           | Default values, `*args`                               |
| ðŸ”„   | Simulated in Python           | Python doesnâ€™t truly allow multiple same-name methods |

---

# Method Overriding

## ðŸ“š **Definition**

**Method Overriding** happens when a **child class** provides a **new implementation** for a method that already exists in its **parent class**.

* The **method name** and **parameters** remain the same.
* The **childâ€™s method** replaces the parentâ€™s method when called on a child object.

---

## ðŸ **Python Example**

```python
class Vehicle:
    def start_engine(self):
        print("Starting a generic vehicle engine ðŸš€")

class Car(Vehicle):
    def start_engine(self):  # Overriding
        print("Starting a car engine ðŸš—")

class Bike(Vehicle):
    def start_engine(self):  # Overriding
        print("Starting a bike engine ðŸ")

# Usage
vehicle = Vehicle()
vehicle.start_engine()  # Output: Starting a generic vehicle engine ðŸš€

car = Car()
car.start_engine()      # Output: Starting a car engine ðŸš—

bike = Bike()
bike.start_engine()     # Output: Starting a bike engine ðŸ
```

---

## ðŸ›  **Key Points**

* **Same name + same parameters** = method overriding.
* Happens in **inheritance** only.
* Enables **runtime polymorphism** â€” the method to call is decided at runtime.
* You can still call the parentâ€™s method using `super()`.

---

## ðŸ”„ **Calling Parent Method**

```python
class Car(Vehicle):
    def start_engine(self):
        super().start_engine()  # Call parent version
        print("Car engine started with extra checks âœ…")
```

---

## ðŸ  **Real-Life Analogy**

Imagine a **company policy**:

* Parent company: â€œWork starts at 9 AM.â€
* Child branch: â€œWork starts at 10 AM because of local conditions.â€
  Same **rule name**, but **different implementation** in each branch.

---

## ðŸŽ¯ **With Icons**

| Icon | Concept              | Example                                       |
| ---- | -------------------- | --------------------------------------------- |
| ðŸ”„   | Override             | Child changes parent method behavior          |
| ðŸ§¬   | Inheritance Required | Works only in a parent-child relationship     |
| â³    | Runtime Decision     | Python decides which method to run at runtime |
| ðŸ“ž   | `super()`            | Call parent method from child                 |

---

# Constructors and Destructors

## ðŸ— **Constructor**

### ðŸ“š **Definition**

A **constructor** is a special method in Python (`__init__`) that **runs automatically** when an object is created.
It is used to **initialize** the objectâ€™s attributes.

---

### ðŸ **Python Constructor Example**

```python
class Car:
    def __init__(self, brand, model):  # Constructor
        self.brand = brand
        self.model = model
        print(f"Car object created: {self.brand} {self.model}")

# Object creation automatically calls the constructor
my_car = Car("Tesla", "Model S")
```

**Output:**

```
Car object created: Tesla Model S
```

---

## ðŸ’£ **Destructor**

### ðŸ“š **Definition**

A **destructor** is a special method in Python (`__del__`) that **runs automatically** when an object is about to be destroyed (garbage collected).
It is used for **cleanup tasks** like closing files or releasing resources.

---

### ðŸ **Python Destructor Example**

```python
class Car:
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model
        print(f"Car object created: {self.brand} {self.model}")

    def __del__(self):  # Destructor
        print(f"Car object destroyed: {self.brand} {self.model}")

# Creating and deleting an object
my_car = Car("Tesla", "Model S")
del my_car  # Manually delete
```

**Output:**

```
Car object created: Tesla Model S
Car object destroyed: Tesla Model S
```

---

## ðŸ  **Real-Life Analogy**

* **Constructor (`__init__`)** â†’ Like **moving into a new house** â€” you unpack and arrange everything when you arrive.
* **Destructor (`__del__`)** â†’ Like **moving out** â€” you pack up and clean before leaving.

---

## ðŸŽ¯ **With Icons**

| Icon | Concept        | Example                              |
| ---- | -------------- | ------------------------------------ |
| ðŸ—   | Constructor    | `__init__` sets initial object state |
| ðŸ›    | Initialization | Assigning `brand`, `model`           |
| ðŸ’£   | Destructor     | `__del__` cleans up before deletion  |
| ðŸ§¹   | Cleanup        | Closing files, releasing memory      |

---

# Access Modifiers

## ðŸ” **Definition**

Access modifiers **control the visibility** of variables and methods in a class â€” i.e., whether they can be accessed from **outside** the class.

In Python, access control is mostly **convention-based**, not enforced like in Java/C++.

---

## ðŸ“Œ **Types of Access Modifiers in Python**

| Modifier      | Syntax       | Access Scope                                      |
| ------------- | ------------ | ------------------------------------------------- |
| **Public**    | `variable`   | Accessible from anywhere                          |
| **Protected** | `_variable`  | Accessible within class & subclasses (convention) |
| **Private**   | `__variable` | Accessible only within the class (name mangling)  |

---

## ðŸ **Python Example**

```python
class Person:
    def __init__(self, name, age, salary):
        self.name = name          # Public
        self._age = age           # Protected (by convention)
        self.__salary = salary    # Private

    def show_salary(self):
        print(f"Salary: â‚¹{self.__salary}")

person = Person("Bharath", 30, 50000)

# Public - Accessible
print(person.name)  # âœ…

# Protected - Accessible but should be avoided directly
print(person._age)  # âš  (Not recommended)

# Private - Direct access will fail
# print(person.__salary)  # âŒ AttributeError

# Access private data through a method
person.show_salary()  # âœ… Salary: â‚¹50000
```

---

## ðŸ›  **How Private Works (Name Mangling)**

Private members are internally renamed:

```python
print(person._Person__salary)  # Works but breaks encapsulation
```

---

## ðŸ  **Real-Life Analogy**

Think of a **company**:

* **Public** (Reception) â†’ Anyone can walk in.
* **Protected** (Staff Room) â†’ Only employees should enter, but not enforced by security guard.
* **Private** (CEOâ€™s Office) â†’ Strict access, only the CEO can enter.

---

## ðŸŽ¯ **With Icons**

| Icon | Modifier  | Example    |
| ---- | --------- | ---------- |
| ðŸŒ   | Public    | `name`     |
| ðŸ›¡   | Protected | `_age`     |
| ðŸ”’   | Private   | `__salary` |

---

