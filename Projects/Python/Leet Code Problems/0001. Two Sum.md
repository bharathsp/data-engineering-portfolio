## ğŸ§® Two Sum Problem

Given an array of integers `nums` and an integer `target`, return **indices** of the two numbers such that they **add up to target**.

> ğŸ¯ **You may assume** that each input would have **exactly one solution**, and you may **not use the same element twice**.

âœ… You can return the answer in **any order**.

---

### ğŸ” Examples

#### Example 1:
```
Input:  nums = [2, 7, 11, 15], target = 9  
Output: [0, 1]  
```
ğŸ’¡ **Explanation**: Because `nums[0] + nums[1] == 9`, we return `[0, 1]`.

---

#### Example 2:
```
Input:  nums = [3, 2, 4], target = 6  
Output: [1, 2]
```

---

#### Example 3:
```
Input:  nums = [3, 3], target = 6  
Output: [0, 1]
```

---

### ğŸ“Œ Constraints
- ğŸ§© `2 <= nums.length <= 10â´`
- ğŸ”¢ `-10â¹ <= nums[i] <= 10â¹`
- ğŸ¯ `-10â¹ <= target <= 10â¹`
- âœ… Only **one valid answer** exists.

---
---

## âœ… 1. Brute Force (O(nÂ²) Time, O(1) Space)

```python
def twoSum(nums, target):
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if nums[i] + nums[j] == target:
                return [i, j]
```

### ğŸ” Explanation:
- Try every pair `(i, j)` and check if `nums[i] + nums[j] == target`.

### âœ… Pros:
- Simple and easy to understand.

### âŒ Cons:
- **Inefficient** for large arrays (quadratic time complexity).

---

## âœ… 2. Hash Map (Optimal) - O(n) Time, O(n) Space

```python
def twoSum(nums, target):
    hashmap = {}  # value -> index
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hashmap:
            return [hashmap[complement], i]
        hashmap[num] = i
```

### ğŸ” Explanation:
- Store each numberâ€™s index in a hash map.
- For each number, check if `target - num` is already in the map.

### âœ… Pros:
- Efficient and optimal: **O(n)** time and space.

### âŒ Cons:
- Requires extra space for the hash map.
