**db.py**

```python
import sqlite3

def save_user(name, age):
    """Saves a user to the database."""
    conn = sqlite3.connect("users.db")
    cursor = conn.cursor()
    cursor.execute("INSERT INTO users (name, age) VALUES (?, ?)", (name, age))
    conn.commit()
    conn.close()
```

---

**test\_db.py**

```python
from db import save_user

def test_save_user(mocker):
    # Mock sqlite3.connect
    mock_conn = mocker.patch("sqlite3.connect")
    mock_cursor = mock_conn.return_value.cursor.return_value

    # Call the function
    save_user("Alice", 30)

    # Assertions
    mock_conn.assert_called_once_with("users.db")
    mock_cursor.execute.assert_called_once_with(
        "INSERT INTO users (name, age) VALUES (?, ?)", ("Alice", 30)
    )
```

---

## **How it works**

### **1. The `save_user` function**

* Connects to a SQLite database file `users.db`.
* Gets a **cursor** object to execute SQL commands.
* Executes an `INSERT` statement with placeholders `?` to prevent SQL injection.
* Commits changes to save them permanently.
* Closes the connection.

---

### **2. The test function with `pytest-mock`**

* **`mock_conn = mocker.patch("sqlite3.connect")`**
  Replaces `sqlite3.connect` with a mock object so that:

  * No real database file is created.
  * We can track calls to it.
* **`mock_cursor = mock_conn.return_value.cursor.return_value`**
  Gets the mocked cursor object to check whether `execute()` was called correctly.
* **Assertions**:

  * `mock_conn.assert_called_once_with("users.db")` → ensures the database connection was made to the right file.
  * `mock_cursor.execute.assert_called_once_with(...)` → checks that the SQL query and parameters are correct.

---

### **Why mock here?**

* Prevents modifying a real database during tests.
* Allows testing database interaction logic without needing an actual `users.db` file.
* Makes tests faster and independent of external resources.

---
