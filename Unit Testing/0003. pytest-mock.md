## 🎭 **What is pytest-mock?**

**pytest-mock** is a plugin for **pytest** that helps you **pretend (mock)** parts of your code during tests.

Think of it like using **stand-ins in a movie** 🎬 — instead of the real actor (your real function/service), you use a temporary fake one for the scene (test).

---

## 🎯 **Why use pytest-mock?**

* 🛡 **Avoid real dependencies** — No hitting real APIs, databases, or payment gateways during testing.
* ⚡ **Speed up tests** — Skip slow operations like network calls.
* 🔍 **Control behavior** — Make the fake object return exactly what you need for the test.
* 🧪 **Test tricky scenarios** — Like API failures or timeouts without actually breaking things.

---

## ⏳ **When to use pytest-mock?**

* When your function depends on **external services** 🌐.
* When you want to **simulate errors** without causing real trouble.
* When you need **predictable, repeatable test results**.

---

## 🛠 **How it works (Real Life Flow)**

Example: Testing a **flight booking app** ✈️

* Your `book_ticket()` function calls a real **Payment API** 💳.
* In tests, you **mock** the payment call so:

  * No real money is charged 💸
  * You control if it “succeeds” or “fails”

---

## ⚙ **Setup & Example**

1️⃣ Install plugin

```bash
pip install pytest-mock
```

2️⃣ Write test with a mock

```python
# flight.py
import payment_gateway

def book_ticket():
    if payment_gateway.process_payment():
        return "Booking Confirmed"
    return "Payment Failed"

# test_flight.py
def test_book_ticket_success(mocker):
    mocker.patch("payment_gateway.process_payment", return_value=True)
    from flight import book_ticket
    assert book_ticket() == "Booking Confirmed"
```

Here:

* `mocker.patch()` replaces the real `process_payment()` with a fake one that always returns `True`.
* No real API calls happen.

---

## 📍 **Quick Analogy:**

Pytest-mock is like **replacing a dangerous stunt** in a movie 🎥 with a **safe stunt double**. The story flows the same, but nobody gets hurt.
