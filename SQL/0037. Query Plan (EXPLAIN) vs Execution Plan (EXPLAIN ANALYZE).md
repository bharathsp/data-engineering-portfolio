# üåü 1. **Query Plan**

**Definition:**

* The **query plan** is PostgreSQL‚Äôs **blueprint of how it intends to execute your SQL query**.
* Generated **before execution** by the query planner/optimizer.
* Includes **join strategies, scans, sorts, and estimated costs**.

**Key Points:**

* Shows **estimated rows, costs, and method** (Seq Scan, Index Scan, Hash Join, etc.)
* Does **not execute the query** ‚Äî only predicts how it will run

### Example:

```sql
EXPLAIN SELECT * FROM Employees WHERE DeptID = 10;
```

Output might be:

```
Index Scan using idx_employees_deptid on employees  (cost=0.28..8.50 rows=3 width=48)
```

* `Index Scan` ‚Üí planned method
* `cost` ‚Üí estimated cost of execution
* `rows` ‚Üí estimated number of rows

---

# üåü 2. **Execution Plan**

**Definition:**

* The **execution plan** is what **actually happened** when the query ran.
* Generated by `EXPLAIN ANALYZE` (or via monitoring tools)
* Shows **actual rows, loops, and time spent**

### Example:

```sql
EXPLAIN ANALYZE SELECT * FROM Employees WHERE DeptID = 10;
```

Output might be:

```
Index Scan using idx_employees_deptid on employees  (cost=0.28..8.50 rows=3 width=48) (actual time=0.005..0.007 rows=3 loops=1)
Planning Time: 0.123 ms
Execution Time: 0.010 ms
```

* `actual time=0.005..0.007` ‚Üí real time per row
* `rows=3` ‚Üí actual rows returned
* Shows **what PostgreSQL actually did**, including loops

---

# üå≥ How it works

When you run:

```sql
EXPLAIN ANALYZE SELECT * FROM Employees;
```

PostgreSQL outputs something like:

```
Seq Scan on employees  (cost=0.00..1.05 rows=5 width=48) (actual time=0.008..0.010 rows=3 loops=1)
Planning Time: 0.123 ms
Execution Time: 0.015 ms
```

---

# üîë Breaking Down the Output

1. **Seq Scan on employees**

   * The query is doing a **Sequential Scan** (scanning every row).
   * If there was an index and the query used it, you‚Äôd see **Index Scan** instead.

2. **cost=0.00..1.05**

   * Estimated **startup cost** and **total cost** for the operation.
   * Measured in **arbitrary units** (not milliseconds).

3. **rows=5**

   * Estimated number of rows the planner expects to process.

4. **width=48**

   * Average size of a row in bytes.

5. **actual time=0.008..0.010**

   * Time in milliseconds actually spent on the operation.
   * Shows **first row time** and **last row time**.

6. **rows=3 loops=1**

   * Actual number of rows returned.
   * Number of times this node of the plan executed (loops).

7. **Planning Time & Execution Time**

   * `Planning Time` ‚Üí time PostgreSQL spent figuring out the best plan.
   * `Execution Time` ‚Üí time spent **actually running the query**.

---

# üîë Difference: Query Plan vs Execution Plan

| Feature             | Query Plan                       | Execution Plan                 |
| ------------------- | -------------------------------- | ------------------------------ |
| Generated by        | Planner/Optimizer                | Planner + Executor             |
| Shows               | Estimated costs, rows, method    | Actual time, rows, loops       |
| Requires execution? | No                               | Yes (EXPLAIN ANALYZE)          |
| Purpose             | Helps optimizer choose best plan | Helps debug performance issues |

---

# üè° Real-Life Analogy

* **Query Plan** ‚Üí GPS route before you start driving
* **Execution Plan** ‚Üí Actual journey with traffic, stops, and delays

---

# ‚ö° Key Notes

1. Always compare **estimated vs actual rows** to spot planner misestimates.
2. Use **EXPLAIN** for planning, **EXPLAIN ANALYZE** to debug performance.
3. Query plan can change with **indexes, statistics, or settings**.
