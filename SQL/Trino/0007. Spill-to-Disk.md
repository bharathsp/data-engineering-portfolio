# ğŸ”¹ What is Spill-to-Disk in Trino?

By default, **Trino is an in-memory query engine** â†’ it tries to keep all intermediate results in **RAM** for speed.

But sometimes:

* You run a **big join** (fact Ã— fact table joins).
* Or a **heavy aggregation** (GROUP BY with lots of distinct keys).
* Or a **sort** on a huge dataset.

ğŸ‘‰ These operations might need **more memory than available per worker**.
Without spill, Trino would fail with an **â€œEXCEEDED\_MEMORY\_LIMITâ€** error.

ğŸ“Œ **Spill-to-disk** = Trino writes (spills) intermediate data to **local SSD/disk** when memory is full â†’ so the query can finish instead of failing.

---

# ğŸ”¹ When Does Spill Happen?

Spill is supported for:

1. **Joins** â†’ if hash table doesnâ€™t fit in memory.
2. **Aggregations** â†’ if group-by state grows too large.
3. **Window Functions** â†’ if partitions are too big.
4. **Order By / Sorts** â†’ if sorted data doesnâ€™t fit in memory.

---

# ğŸ”¹ How to Enable Spill in Trino

You enable it in the **config.properties** (on workers and coordinators if needed):

```properties
experimental.spill-enabled=true
```

Then, configure specific spill settings:

### 1. Spill Paths (local directories for spill files)

```properties
spiller-spill-path=/data/trino/spill
```

ğŸ‘‰ This should be a **fast local disk (NVMe SSD preferred)**, not network storage.

You can set multiple paths (comma-separated) if workers have multiple disks:

```properties
spiller-spill-path=/disk1/trino/spill,/disk2/trino/spill
```

---

### 2. Memory Thresholds

* `query.max-memory` â†’ per query memory limit before spilling starts.
* `query.max-total-memory-per-node` â†’ total memory per node.
* `query.max-spill-per-node` â†’ how much disk can be used for spilling.
* `query.max-spill-per-query` â†’ per-query spill disk limit.

Example:

```properties
query.max-memory=4GB
query.max-total-memory-per-node=16GB
query.max-spill-per-node=100GB
query.max-spill-per-query=20GB
```

---

# ğŸ”¹ Monitoring Spill

When a query spills:

* In **Trino Web UI (Query â†’ Stage â†’ Task details)** youâ€™ll see metrics like:

  * *Spilled bytes*
  * *Spill count*

* In logs you may see entries like:

  ```
  INFO  SpillOperator - Spilling 1.2GB to /data/trino/spill/query_20250919...
  ```

---

# ğŸ”¹ Pros & Cons of Spill

âœ… **Advantages**

* Prevents OOM (out of memory) query failures.
* Lets you run much larger queries without increasing RAM.
* Enables stability for BI and ETL workloads.

âš ï¸ **Trade-offs**

* **Spill = slower queries** (disk I/O is slower than RAM).
* Requires **enough local disk space** (fast SSD recommended).
* Misconfigured spill â†’ queries may still fail (if disk limits reached).

---

# ğŸ”¹ When to Use Spill?

* **Enable** if:

  * You run **large joins/aggregations** and see frequent OOM errors.
  * You have **concurrent users** with big queries.
  * You can provide **fast local SSDs** for spill.

* **Avoid / Limit** if:

  * You already fit workloads in memory comfortably.
  * Youâ€™re on **slow disks** (HDDs or network volumes â†’ will cause major slowdowns).

---

âœ… **In summary**:

* Spill-to-disk = safety valve to avoid OOM.
* Configure in `config.properties` (`experimental.spill-enabled=true`).
* Tune memory + spill limits carefully.
* Always use **NVMe SSDs** for best performance.
