# ðŸ”¹ What is a Resource Group in Trino?

A **Resource Group** in Trino is a **container for managing query concurrency, memory, and scheduling policies**.

* Think of it as a **bucket (queue + quota)** where incoming queries are placed before execution.
* Each resource group defines:

  * How many queries can run at once (`hardConcurrencyLimit`).
  * How much memory they can use (`softMemoryLimit`).
  * How queries inside the group are scheduled (`fair`, `weighted_fair`, etc.).
* Queries are assigned to resource groups using **selectors** (rules based on user, source, or query type).

So:
ðŸ‘‰ **Resource group = queue + resource limits + scheduling rules.**

---

# ðŸ”¹ Why Resource Groups?

* Prevent a single workload (e.g., ETL job) from overwhelming the cluster.
* Ensure **fairness** across workloads (BI dashboards, ad-hoc analysis, scheduled ETL).
* Enforce **SLAs** by prioritizing some queries over others.
* Support **multi-tenancy** in shared Trino clusters.

---

# ðŸ”¹ Structure of Resource Groups

They are **hierarchical**.

* You can have a **root group** (global limits).
* Subgroups under it for different workloads (ETL, BI, ad-hoc).
* Each group can further be divided into smaller groups.

ðŸ“Œ Example hierarchy:

```
root (cluster-wide)
 â”œâ”€â”€ BI (dashboards)
 â”œâ”€â”€ ETL (scheduled jobs)
 â””â”€â”€ Adhoc (CLI/analyst queries)
```

---

# ðŸ”¹ Example Config

ðŸ“Œ `resource-groups.json`

```json
{
  "rootGroups": [
    {
      "name": "global",
      "hardConcurrencyLimit": 100,
      "softMemoryLimit": "80%",
      "schedulingPolicy": "fair",
      "subGroups": [
        {
          "name": "etl",
          "hardConcurrencyLimit": 20,
          "softMemoryLimit": "40%",
          "schedulingPolicy": "weighted_fair",
          "schedulingWeight": 2
        },
        {
          "name": "bi",
          "hardConcurrencyLimit": 30,
          "softMemoryLimit": "30%",
          "schedulingPolicy": "weighted_fair",
          "schedulingWeight": 3
        },
        {
          "name": "adhoc",
          "hardConcurrencyLimit": 10,
          "softMemoryLimit": "10%",
          "schedulingPolicy": "fair"
        }
      ]
    }
  ],
  "selectors": [
    { "user": "etl_user", "group": "global.etl" },
    { "source": "powerbi", "group": "global.bi" },
    { "source": "cli", "group": "global.adhoc" }
  ]
}
```

### Key points:

* `global` â†’ cluster-wide cap of 100 queries and 80% memory.
* `etl` â†’ max 20 queries, higher scheduling weight (more preference).
* `bi` â†’ gets bigger share of slots than ad-hoc (weight 3 vs weight 1).
* `selectors` â†’ route queries to the right group based on user/source.

---

# ðŸ”¹ Monitoring Resource Groups

* **Trino UI** â†’ shows queued/running queries and which group they belong to.
* **JMX metrics** â†’ `trino.execution.resource-groups.*` to track queue wait times, running queries, etc.
* **Logs** â†’ queries will show `QUEUED` state if waiting for a slot in a group.

---

# ðŸ”¹ Difference Between Resource Group and Query Queue

* **Resource Group** = the definition of limits (concurrency, memory, policies).
* **Queue** = the actual waiting line inside a resource group.
  ðŸ‘‰ Every resource group automatically acts as a queue if too many queries are assigned.

---

âš¡ In short:
A **resource group in Trino** is a way to organize and control **query concurrency, memory, and scheduling**. It ensures fairness, avoids overload, and enforces priorities in multi-user clusters.
