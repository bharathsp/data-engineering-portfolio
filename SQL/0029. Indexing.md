### ğŸ” What is **Indexing in SQL**?

**Indexing** in SQL is a **performance optimization technique** that speeds up the retrieval of rows from a database table.

---

### ğŸ“˜ Basic Definition:

An **index** is a **data structure** (typically a B-tree or hash) associated with a table column(s) that helps the **database engine locate rows faster**, just like an index in a book helps you find topics quickly.

---

### âœ… Why Use Indexes?

Without an index, SQL must perform a **full table scan**, checking every row to find matches â€” slow for large datasets.

With an index:

* Searches become faster (e.g., using `WHERE`, `JOIN`, or `ORDER BY`).
* Improves performance of read-heavy queries.

---

### ğŸ§± Types of Indexes:

| Type                    | Description                                        |
| ----------------------- | -------------------------------------------------- |
| **Single-column index** | Index on one column                                |
| **Composite index**     | Index on multiple columns                          |
| **Unique index**        | Ensures all values in a column are unique          |
| **Full-text index**     | For fast searching of string data                  |
| **Clustered index**     | Sorts the table physically (usually one per table) |
| **Non-clustered index** | Separate structure from data (can have many)       |

---

### ğŸ§ª Example:

```sql
-- Create an index on the "email" column in the "users" table
CREATE INDEX idx_email ON users(email);
```

Now this query will be faster:

```sql
SELECT * FROM users WHERE email = 'abc@example.com';
```

---

### âš ï¸ Considerations:

* Indexes **consume storage**.
* **Too many indexes** slow down `INSERT`, `UPDATE`, and `DELETE` operations.
* Indexes need to be **maintained** as data changes.

---

### ğŸ§  Tip:

Use indexes on columns that are frequently:

* Filtered in `WHERE`
* Joined in `JOIN`
* Ordered in `ORDER BY`
* Grouped in `GROUP BY`

---

# Types of Index:

# ğŸŒ³ 1. **B-Tree Index** (Balanced Tree)

ğŸ“– **What it is:**

* A tree-like structure where data is stored in **sorted order**.
* Common **default index** in most SQL databases (MySQL, Postgres, Oracle).
* Supports **range queries, sorting, prefix lookups**.

---

### ğŸ—‚ Example

Suppose we have a `Students` table:

| StudentID | Name  | Age | GPA |
| --------- | ----- | --- | --- |
| 101       | Alice | 20  | 3.7 |
| 102       | Bob   | 22  | 3.4 |
| 103       | Carol | 19  | 3.9 |
| 104       | David | 21  | 3.2 |

If we create:

```sql
CREATE INDEX idx_students_age ON Students(Age);
```

â¡ï¸ Database stores **Age** in a balanced tree.

### ğŸŒ³ B-Tree Structure (simplified)

```
           [20]
         /      \
      [19]      [21, 22]
```

### Explanation:

1. **Root Node**: `[20]`

   * Middle value of ages, keeps tree balanced

2. **Left Child**: `[19]`

   * Ages less than 20

3. **Right Child**: `[21, 22]`

   * Ages greater than 20

4. **Leaves** point to **actual rows** in the table:

   * 19 â†’ Carol
   * 20 â†’ Alice
   * 21 â†’ David
   * 22 â†’ Bob

ğŸ“Œ Query:

```sql
SELECT * FROM Students WHERE Age BETWEEN 19 AND 21;
```

ğŸ‘‰ B-Tree index is super efficient here because it can **traverse sorted nodes**.

**Step-by-step traversal**:

1. Start at **root `[20]`**
2. Check left child `[19]` â†’ include Carol
3. Root `[20]` â†’ include Alice
4. Right child `[21,22]` â†’ include David, stop at 22 (out of range)

âœ… Only rows 19, 20, 21 are scanned â†’ very efficient

---

### ğŸ¡ Real-life Analogy

Like a **phonebook ğŸ“–** â†’ names are sorted alphabetically â†’ easy to find a range (`Aâ€“C`).

---

### âœ… Advantages

* Supports **range queries** (>, <, BETWEEN)
* Efficient for **ORDER BY** and **GROUP BY**
* Works well for **most general-purpose queries**

---

### ğŸ“Œ Use cases

* Searching customers between ages 25â€“30
* Finding sales between certain dates
* Sorting results quickly

---

# ğŸ”‘ 2. **Hash Index**

ğŸ“– **What it is:**

* Uses a **hash function** to map values to locations.
* Best for **exact matches (=)**.
* No order, so range queries are **not supported**.

---

### ğŸ—‚ Example

Same `Students` table.

| StudentID | Name  | Age |
| --------- | ----- | --- |
| 101       | Alice | 20  |
| 102       | Bob   | 22  |
| 103       | Carol | 19  |
| 104       | David | 21  |

We create a **hash index on `StudentID`**:

```sql
CREATE INDEX idx_students_id_hash ON Students USING HASH (StudentID);
```

* A **hash function** converts the `StudentID` to a **bucket number**.
* Each bucket stores **pointers to the actual row**.
* Lookup is **direct**, no scanning or sorting.

```
Hash Function: hash(StudentID) % 4  â†’ 4 buckets (0,1,2,3)

Buckets:

Bucket 0: 104 â†’ David
Bucket 1: 101 â†’ Alice
Bucket 2: 102 â†’ Bob
Bucket 3: 103 â†’ Carol
```

* Query:

```sql
SELECT * FROM Students WHERE StudentID = 103;
```

* Step 1: Compute hash â†’ `hash(103) % 4 = 3`
* Step 2: Go directly to **Bucket 3**
* Step 3: Fetch **Carolâ€™s row**

âœ… Only **one bucket lookup** â†’ extremely fast for equality queries

ğŸ‘‰ Hash index quickly computes a **hash(StudentID=103)** and jumps directly to the record.

---

### ğŸ¡ Real-life Analogy

Like a **locker system ğŸ”‘** â†’ you know locker #103 â†’ directly open it, no need to scan all.

---

### âœ… Advantages

* Super fast for **equality lookups (=)**
* Less storage overhead than B-Trees

### âŒ Disadvantage

* No support for `<, >, BETWEEN`
* Rehashing may be expensive

---

### ğŸ“Œ Use cases

* Looking up employees by **ID**
* Fetching product by **SKU code**
* Authentication (usernames, hashed passwords)

---

# ğŸ—‚ï¸ 3. **Bitmap Index**

ğŸ“– **What it is:**

* Uses **bitmaps (0/1 arrays)** for distinct values of a column.
* Very efficient when column has **low cardinality** (few distinct values).
* Often used in **data warehouses**.

---

### ğŸ—‚ Example

Add `Gender` column to `Students` table:

| StudentID | Name  | Age | Gender |
| --------- | ----- | --- | ------ |
| 101       | Alice | 20  | F      |
| 102       | Bob   | 22  | M      |
| 103       | Carol | 19  | F      |
| 104       | David | 21  | M      |

For `Gender`, bitmap index:

* **M â†’ \[0,1,0,1]**
* **F â†’ \[1,0,1,0]**

ğŸ“Œ Query:

```sql
SELECT * FROM Students WHERE Gender = 'F';
```

ğŸ‘‰ Just read bitmap â†’ find positions (1s) â†’ fetch rows.

---

### ğŸ¡ Real-life Analogy

Like **attendance sheet âœ…âŒ** â†’ one column per student, tick marks show presence.
You can quickly **AND/OR** conditions across bitmaps.

---

### âœ… Advantages

* Very efficient for **low-cardinality columns** (Yes/No, Gender, Region)
* Fast for **complex boolean conditions** (e.g., `Gender='F' AND Age<21`)

### âŒ Disadvantage

* Inefficient for **high-cardinality** (e.g., `Salary`, `Name`)
* Needs more storage space for many distinct values

---

### ğŸ“Œ Use cases

* Data warehousing (OLAP)
* Filtering by **flags, categories, or booleans**
* Analytics queries (e.g., customers in Region=A **AND** Active=Yes)

---

# ğŸŒŸ 4. **Covered Index**

* A **covered index** (also called an **index-only scan**) is an index that **contains all the columns needed by a query**.
* When a query can be satisfied entirely from the index, PostgreSQL **does not need to access the main table**.
* Result â†’ **faster query** because fewer disk reads.

---

### ğŸŒ³ How it Works

Suppose we have a table:

**Employees**

| EmpID | Name  | DeptID | Salary |
| ----- | ----- | ------ | ------ |
| 1     | Alice | 10     | 50000  |
| 2     | Bob   | 20     | 60000  |
| 3     | Carol | 10     | 55000  |

---

### Example: Create a Covered Index

```sql
-- Index includes both DeptID and Salary
CREATE INDEX idx_dept_salary ON Employees(DeptID, Salary);
```

Query:

```sql
SELECT DeptID, Salary
FROM Employees
WHERE DeptID = 10;
```

âœ… PostgreSQL can satisfy this query **directly from the index** â†’ **no table scan needed**

---

### ğŸ”‘ Advantages

* ğŸš€ **Faster queries**: Index-only scan avoids reading the table itself
* ğŸ’¾ **Reduces I/O**: Only the index pages are accessed
* ğŸ“Š Great for **reporting queries / aggregates**

---

### âš¡ When to Use

* Columns in **WHERE clause** + columns in **SELECT** are all part of the index
* Frequently queried columns for **filtering / reporting**
* Large tables where **I/O is expensive**

---

### ğŸ¡ Real-Life Analogy

Think of a **restaurant menu index ğŸ“–**:

* Table = entire kitchen (all ingredients, recipes)
* Index = small menu card with key info (Dish + Price)
* If a customer asks only for â€œDish + Priceâ€ â†’ chef doesnâ€™t need to open the whole kitchen, just use menu card â†’ faster!

---

* ğŸŒ³ **B-Tree** â†’ Sorted, best for ranges ğŸ“–
* ğŸ”‘ **Hash** â†’ Exact match lookups only ğŸ”’
* ğŸ—‚ï¸ **Bitmap** â†’ Few distinct values, low-cardinality analytical filters, great for boolean logic âœ…âŒ
