# ğŸŒŸ 1. What is a Materialized View?

* A **materialized view** is a **physical copy of the result of a query** stored on disk.
* Unlike a regular view, which executes the query **every time it is accessed**, a materialized view **stores the data** for faster retrieval.
* You can **refresh** it periodically to update the data.

**Analogy:**

* Regular view â†’ A **live news feed ğŸ“°**, always up-to-date but slow to fetch
* Materialized view â†’ A **printed newspaper ğŸ—ï¸**, fast to read, needs refresh to get new news

---

# ğŸŒ³ 2. Creating a Materialized View

```sql
CREATE MATERIALIZED VIEW emp_summary AS
SELECT DeptID, COUNT(*) AS total_employees, AVG(Salary) AS avg_salary
FROM Employees
GROUP BY DeptID;
```

* Stores **summary data** per department.
* Querying this view is **faster** because aggregation is precomputed.

---

# ğŸŒŸ 3. Querying a Materialized View

```sql
SELECT * FROM emp_summary;
```

* Reads **precomputed data** instead of scanning the full Employees table.

---

# ğŸŒ³ 4. Refreshing a Materialized View

```sql
REFRESH MATERIALIZED VIEW emp_summary;
```

* Updates the stored data to reflect **changes in the underlying tables**.

* Can be run **manually** or scheduled via **cron / job scheduler**.

* Optional: **CONCURRENTLY** (available in PostgreSQL 9.4+)

```sql
REFRESH MATERIALIZED VIEW CONCURRENTLY emp_summary;
```

* Allows **queries to continue running while refreshing**
* Requires **unique index** on the materialized view

---

# ğŸŒŸ 5. Advantages

* ğŸš€ **Faster queries** for heavy aggregations or joins
* ğŸ’¾ **Reduced CPU usage** because results are precomputed
* ğŸ› ï¸ Can be **indexed** like a normal table

---

# ğŸŒŸ 6. Use Cases

* Reporting dashboards
* Precomputed summaries (e.g., daily sales totals)
* Complex joins/aggregations that donâ€™t change frequently

---

# ğŸ¡ Real-Life Analogy

* Imagine a **restaurant menu ğŸ“**:

  * Regular view â†’ chef prepares fresh every order
  * Materialized view â†’ pre-made dishes ready to serve, refresh daily
