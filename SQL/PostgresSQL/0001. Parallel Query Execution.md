## ğŸ”¹ What is Parallel Query Execution?

Normally, PostgreSQL queries run **sequentially on a single CPU core**.
With **parallel queries**, PostgreSQL splits the work into **smaller tasks** and distributes them across multiple worker processes â†’ results are merged and returned faster.

Think of it like this:
ğŸ§‘â€ğŸŒ¾ A single farmer harvesting a field (sequential).
ğŸ‘¨â€ğŸŒ¾ğŸ‘©â€ğŸŒ¾ğŸ‘¨â€ğŸŒ¾ Multiple farmers harvesting different parts simultaneously (parallel).

---

## ğŸ”¹ How it Works in PostgreSQL

When you run a query:

1. **Leader process** (main backend) decides whether to use parallelism.
2. If yes â†’ spawns **parallel workers**.
3. Each worker scans/filters/aggregates a portion of the data.
4. The leader gathers results and returns them.

---

## ğŸ”¹ Requirements for Parallel Queries

âœ… PostgreSQL â‰¥ 9.6 (basic), improved in 10â€“15
âœ… The table must be large enough (small tables wonâ€™t trigger parallelism)
âœ… Costs & settings must allow parallelism (`max_parallel_workers_per_gather > 0`)

---

## ğŸ”¹ Important Settings

```sql
-- Maximum workers a single parallel query can use
SET max_parallel_workers_per_gather = 4;

-- Cost parameters (affect planner decision)
SET parallel_setup_cost = 1000;
SET parallel_tuple_cost = 0.1;
```

---

## ğŸ”¹ Example 1: Parallel Sequential Scan

```sql
EXPLAIN ANALYZE
SELECT COUNT(*) 
FROM employees;
```

ğŸ“Œ If the table is large â†’ youâ€™ll see something like:

```
Gather  (cost=1000.00..20000.00 rows=1 width=8)
  Workers Planned: 2
  Workers Launched: 2
  ->  Parallel Seq Scan on employees ...
```

ğŸ‘‰ Here, multiple workers scan chunks of the `employees` table simultaneously.

---

## ğŸ”¹ Example 2: Parallel Aggregation

```sql
EXPLAIN ANALYZE
SELECT department_id, AVG(salary)
FROM employees
GROUP BY department_id;
```

* Each worker calculates partial averages.
* Leader merges them â†’ final result.

---

## ğŸ”¹ Example 3: Parallel Join

```sql
EXPLAIN ANALYZE
SELECT e.name, d.department_name
FROM employees e
JOIN departments d
ON e.department_id = d.id;
```

If tables are large, Postgres may use:

```
Gather Merge
  ->  Parallel Hash Join ...
```

---

## ğŸ”¹ When to Use Parallel Queries

âœ… Analytical queries (OLAP)
âœ… Full table scans
âœ… Aggregations (SUM, COUNT, AVG, GROUP BY)
âœ… Joins on large tables

âŒ Not useful for:

* Small tables
* Highly selective queries (few rows returned)
* Index-only lookups

---

## ğŸ”¹ Real-Life Analogy

Imagine you want to count books ğŸ“š in a huge library:

* **Sequential**: 1 librarian counts every book.
* **Parallel**: 4 librarians each count different sections, then combine totals.
