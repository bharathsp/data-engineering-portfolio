## 🔹 What is Parallel Query Execution?

Normally, PostgreSQL queries run **sequentially on a single CPU core**.
With **parallel queries**, PostgreSQL splits the work into **smaller tasks** and distributes them across multiple worker processes → results are merged and returned faster.

Think of it like this:
🧑‍🌾 A single farmer harvesting a field (sequential).
👨‍🌾👩‍🌾👨‍🌾 Multiple farmers harvesting different parts simultaneously (parallel).

---

## 🔹 How it Works in PostgreSQL

When you run a query:

1. **Leader process** (main backend) decides whether to use parallelism.
2. If yes → spawns **parallel workers**.
3. Each worker scans/filters/aggregates a portion of the data.
4. The leader gathers results and returns them.

---

## 🔹 Requirements for Parallel Queries

✅ PostgreSQL ≥ 9.6 (basic), improved in 10–15
✅ The table must be large enough (small tables won’t trigger parallelism)
✅ Costs & settings must allow parallelism (`max_parallel_workers_per_gather > 0`)

---

## 🔹 Important Settings

```sql
-- Maximum workers a single parallel query can use
SET max_parallel_workers_per_gather = 4;

-- Cost parameters (affect planner decision)
SET parallel_setup_cost = 1000;
SET parallel_tuple_cost = 0.1;
```

---

## 🔹 Example 1: Parallel Sequential Scan

```sql
EXPLAIN ANALYZE
SELECT COUNT(*) 
FROM employees;
```

📌 If the table is large → you’ll see something like:

```
Gather  (cost=1000.00..20000.00 rows=1 width=8)
  Workers Planned: 2
  Workers Launched: 2
  ->  Parallel Seq Scan on employees ...
```

👉 Here, multiple workers scan chunks of the `employees` table simultaneously.

---

## 🔹 Example 2: Parallel Aggregation

```sql
EXPLAIN ANALYZE
SELECT department_id, AVG(salary)
FROM employees
GROUP BY department_id;
```

* Each worker calculates partial averages.
* Leader merges them → final result.

---

## 🔹 Example 3: Parallel Join

```sql
EXPLAIN ANALYZE
SELECT e.name, d.department_name
FROM employees e
JOIN departments d
ON e.department_id = d.id;
```

If tables are large, Postgres may use:

```
Gather Merge
  ->  Parallel Hash Join ...
```

---

## 🔹 When to Use Parallel Queries

✅ Analytical queries (OLAP)
✅ Full table scans
✅ Aggregations (SUM, COUNT, AVG, GROUP BY)
✅ Joins on large tables

❌ Not useful for:

* Small tables
* Highly selective queries (few rows returned)
* Index-only lookups

---

## 🔹 Real-Life Analogy

Imagine you want to count books 📚 in a huge library:

* **Sequential**: 1 librarian counts every book.
* **Parallel**: 4 librarians each count different sections, then combine totals.
