You are provided with two tables:

* `olist_orders`: Contains order-level data including `order_id`, `order_purchase_timestamp`, `customer_id`
* `olist_order_payments`: Contains payment information per order with fields `order_id`, `payment_value`

---

### **Task:**

Write a SQL query to:

1. Group orders by **year** and **month** of purchase.
2. Count the total number of orders per year and month.
3. Categorize orders into **three loyalty segments** based on the **total payment per order**:

   * `loyalty_Low_cnt`: payment < 100
   * `loyalty_Medium_cnt`: 100 ≤ payment ≤ 500
   * `loyalty_High_cnt`: payment > 500

Return the counts of each loyalty segment for every year-month combination.

---

### ✅ **SQL Solution:**

```sql
SELECT
  strftime('%Y', order_purchase_timestamp) AS order_year,
  strftime('%m', order_purchase_timestamp) AS order_month,
  COUNT(order_id) AS total_orders,
  SUM(CASE WHEN payment_per_order < 100 THEN 1 ELSE 0 END) AS loyalty_Low_cnt,
  SUM(CASE WHEN payment_per_order BETWEEN 100 AND 500 THEN 1 ELSE 0 END) AS loyalty_Medium_cnt,
  SUM(CASE WHEN payment_per_order > 500 THEN 1 ELSE 0 END) AS loyalty_High_cnt
FROM (
  SELECT
    order_id,
    order_purchase_timestamp,
    customer_id,
    SUM(payment_value) AS payment_per_order
  FROM olist_orders
  JOIN olist_order_payments USING(order_id)
  GROUP BY order_id
)
GROUP BY order_year, order_month;
```

---

### ✅ **Explanation:**

* The **inner query** aggregates total `payment_value` per `order_id` to get `payment_per_order`.
* The **outer query** extracts the year and month from `order_purchase_timestamp`, and:

  * Counts total orders
  * Classifies each order into a loyalty bucket (`Low`, `Medium`, `High`) based on its `payment_per_order`
