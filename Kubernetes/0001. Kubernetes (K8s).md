# â˜¸ï¸ **What is Kubernetes?**

<img width="340" height="2160" alt="image" src="https://github.com/user-attachments/assets/536eeb68-555a-4f25-8528-a45848c068cc" />

* **Kubernetes (K8s)** is an **open-source container orchestration platform**.
* It helps you **deploy, scale, and manage containerized applications** (like Docker containers).
* Originally built by **Google**, now maintained by the **Cloud Native Computing Foundation (CNCF)**.

ğŸ‘‰ In simple terms:
Itâ€™s like an **operating system for your containers** â€“ schedules them, heals them if they fail, and scales them up or down automatically.

---

## âš¡ Why Kubernetes for Microservices?

Microservices = many small independent services â†’ ğŸš€ high flexibility, but hard to manage.

Kubernetes helps by:

* ğŸ“¦ Deploying each microservice in a **container (Pod)**.
* ğŸ”„ **Scaling** microservices independently.
* ğŸŒ Providing **service discovery & load balancing**.
* ğŸ›¡ï¸ Ensuring **self-healing** (restarts failed pods).
* ğŸ”€ Handling **rolling updates** with zero downtime.
* ğŸ”’ Offering **config & secret management**.

---

# ğŸ—ï¸ **How to Configure Microservices Architecture in Kubernetes**

Imagine we have an **E-commerce app** with 3 microservices:

1. ğŸ›’ **Cart Service**
2. ğŸ‘¤ **User Service**
3. ğŸ’³ **Payment Service**

---

### ğŸ”¹ Step 1: Containerize Each Microservice

* Write Dockerfiles for each service.
* Example (Cart Service Dockerfile):

```dockerfile
FROM python:3.9-slim
WORKDIR /app
COPY . .
RUN pip install -r requirements.txt
CMD ["python", "cart_service.py"]
```

Push images to a **container registry** (DockerHub, ECR, GCR).

---

### ğŸ”¹ Step 2: Define Kubernetes Deployments

Each service gets a **Deployment** (manages pods) + **Service** (exposes pods).

**cart-deployment.yaml**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cart-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: cart
  template:
    metadata:
      labels:
        app: cart
    spec:
      containers:
      - name: cart
        image: myrepo/cart-service:1.0
        ports:
        - containerPort: 5000
---
apiVersion: v1
kind: Service
metadata:
  name: cart-service
spec:
  selector:
    app: cart
  ports:
    - protocol: TCP
      port: 80
      targetPort: 5000
  type: ClusterIP
```

ğŸ‘‰ Repeat similar configs for **user-service** and **payment-service**.

---

### ğŸ”¹ Step 3: Expose Services with Ingress

Ingress acts like a **smart router** for external traffic.

**ingress.yaml**

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ecommerce-ingress
spec:
  rules:
  - host: myshop.com
    http:
      paths:
      - path: /cart
        pathType: Prefix
        backend:
          service:
            name: cart-service
            port:
              number: 80
      - path: /user
        pathType: Prefix
        backend:
          service:
            name: user-service
            port:
              number: 80
      - path: /payment
        pathType: Prefix
        backend:
          service:
            name: payment-service
            port:
              number: 80
```

Now:

* `myshop.com/cart` â†’ Cart Service
* `myshop.com/user` â†’ User Service
* `myshop.com/payment` â†’ Payment Service

---

### ğŸ”¹ Step 4: Add ConfigMaps & Secrets

* ConfigMaps â†’ Non-sensitive configs (DB URLs, ENV variables).
* Secrets â†’ Sensitive data (API keys, passwords).

---

### ğŸ”¹ Step 5: Setup Observability

* ğŸ“Š **Prometheus + Grafana** for metrics.
* ğŸ“œ **ELK Stack (Elasticsearch, Logstash, Kibana)** or **CloudWatch** for logs.

---

### ğŸ”¹ Step 6: CI/CD Integration

* Use **Jenkins, GitHub Actions, or ArgoCD** to automate builds, tests, and deployments.

---

# ğŸ–¼ï¸ Visual Flow (Microservices in Kubernetes)

```
ğŸŒ Client â†’ Ingress â†’ 
   â”œâ”€â”€ ğŸ›’ Cart Service (Pods, Deployment, Service)
   â”œâ”€â”€ ğŸ‘¤ User Service (Pods, Deployment, Service)
   â””â”€â”€ ğŸ’³ Payment Service (Pods, Deployment, Service)
```

---

âœ… **In short**:
Kubernetes provides the **foundation for running microservices at scale** by handling deployment, scaling, service discovery, and resilience automatically.
