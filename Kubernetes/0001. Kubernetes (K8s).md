# ☸️ **What is Kubernetes?**

<img width="340" height="2160" alt="image" src="https://github.com/user-attachments/assets/536eeb68-555a-4f25-8528-a45848c068cc" />

* **Kubernetes (K8s)** is an **open-source container orchestration platform**.
* It helps you **deploy, scale, and manage containerized applications** (like Docker containers).
* Originally built by **Google**, now maintained by the **Cloud Native Computing Foundation (CNCF)**.

👉 In simple terms:
It’s like an **operating system for your containers** – schedules them, heals them if they fail, and scales them up or down automatically.

---

## ⚡ Why Kubernetes for Microservices?

Microservices = many small independent services → 🚀 high flexibility, but hard to manage.

Kubernetes helps by:

* 📦 Deploying each microservice in a **container (Pod)**.
* 🔄 **Scaling** microservices independently.
* 🌐 Providing **service discovery & load balancing**.
* 🛡️ Ensuring **self-healing** (restarts failed pods).
* 🔀 Handling **rolling updates** with zero downtime.
* 🔒 Offering **config & secret management**.

---

# 🏗️ **How to Configure Microservices Architecture in Kubernetes**

Imagine we have an **E-commerce app** with 3 microservices:

1. 🛒 **Cart Service**
2. 👤 **User Service**
3. 💳 **Payment Service**

---

### 🔹 Step 1: Containerize Each Microservice

* Write Dockerfiles for each service.
* Example (Cart Service Dockerfile):

```dockerfile
FROM python:3.9-slim
WORKDIR /app
COPY . .
RUN pip install -r requirements.txt
CMD ["python", "cart_service.py"]
```

Push images to a **container registry** (DockerHub, ECR, GCR).

---

### 🔹 Step 2: Define Kubernetes Deployments

Each service gets a **Deployment** (manages pods) + **Service** (exposes pods).

**cart-deployment.yaml**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cart-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: cart
  template:
    metadata:
      labels:
        app: cart
    spec:
      containers:
      - name: cart
        image: myrepo/cart-service:1.0
        ports:
        - containerPort: 5000
---
apiVersion: v1
kind: Service
metadata:
  name: cart-service
spec:
  selector:
    app: cart
  ports:
    - protocol: TCP
      port: 80
      targetPort: 5000
  type: ClusterIP
```

👉 Repeat similar configs for **user-service** and **payment-service**.

---

### 🔹 Step 3: Expose Services with Ingress

Ingress acts like a **smart router** for external traffic.

**ingress.yaml**

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ecommerce-ingress
spec:
  rules:
  - host: myshop.com
    http:
      paths:
      - path: /cart
        pathType: Prefix
        backend:
          service:
            name: cart-service
            port:
              number: 80
      - path: /user
        pathType: Prefix
        backend:
          service:
            name: user-service
            port:
              number: 80
      - path: /payment
        pathType: Prefix
        backend:
          service:
            name: payment-service
            port:
              number: 80
```

Now:

* `myshop.com/cart` → Cart Service
* `myshop.com/user` → User Service
* `myshop.com/payment` → Payment Service

---

### 🔹 Step 4: Add ConfigMaps & Secrets

* ConfigMaps → Non-sensitive configs (DB URLs, ENV variables).
* Secrets → Sensitive data (API keys, passwords).

---

### 🔹 Step 5: Setup Observability

* 📊 **Prometheus + Grafana** for metrics.
* 📜 **ELK Stack (Elasticsearch, Logstash, Kibana)** or **CloudWatch** for logs.

---

### 🔹 Step 6: CI/CD Integration

* Use **Jenkins, GitHub Actions, or ArgoCD** to automate builds, tests, and deployments.

---

# 🖼️ Visual Flow (Microservices in Kubernetes)

```
🌐 Client → Ingress → 
   ├── 🛒 Cart Service (Pods, Deployment, Service)
   ├── 👤 User Service (Pods, Deployment, Service)
   └── 💳 Payment Service (Pods, Deployment, Service)
```

---

✅ **In short**:
Kubernetes provides the **foundation for running microservices at scale** by handling deployment, scaling, service discovery, and resilience automatically.
