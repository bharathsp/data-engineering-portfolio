# 🔄 **flatMap() in Spark**

## 🧩 What is `flatMap()`?

* `flatMap()` is a **transformation** in Spark.
* It applies a function to each element of the RDD and **flattens the results** into a single RDD.
* Unlike `map()`, where each input gives **exactly one output**, in `flatMap()` each input can give **zero, one, or many outputs**.

👉 Think:

* `map()` → **1-to-1** mapping.
* `flatMap()` → **1-to-many** mapping + flattening.

---

## ⚡ Syntax

```python
rdd.flatMap(function)
```

---

## 📊 Example 1: Splitting Sentences into Words

```python
from pyspark import SparkContext
sc = SparkContext("local", "FlatMapExample")

sentences = ["hello world", "spark is fast", "flatmap vs map"]
rdd = sc.parallelize(sentences)

words_rdd = rdd.flatMap(lambda line: line.split(" "))
print(words_rdd.collect())
```

**Output:**

```
['hello', 'world', 'spark', 'is', 'fast', 'flatmap', 'vs', 'map']
```

👉 Each sentence produced multiple words, and `flatMap()` flattened them into one list.

---

## 📊 Example 2: Using `map()` vs `flatMap()`

```python
mapped = rdd.map(lambda line: line.split(" "))
flatmapped = rdd.flatMap(lambda line: line.split(" "))

print("Map:", mapped.collect())
print("FlatMap:", flatmapped.collect())
```

**Output:**

```
Map: [['hello', 'world'], ['spark', 'is', 'fast'], ['flatmap', 'vs', 'map']]
FlatMap: ['hello', 'world', 'spark', 'is', 'fast', 'flatmap', 'vs', 'map']
```

👉 `map()` keeps lists **nested**, while `flatMap()` **flattens** them.

---

## 📊 Example 3: Filtering with flatMap

```python
nums = [1, 2, 3, 4]
rdd = sc.parallelize(nums)

flatmapped = rdd.flatMap(lambda x: (x, x*10) if x % 2 == 0 else [])
print(flatmapped.collect())
```

**Output:**

```
[2, 20, 4, 40]
```

👉 Odd numbers return empty lists (`[]`), so they vanish.

---

# 🖼️ Analogy

Imagine you’re unpacking **boxes 📦**:

* `map()` → You take each box and put it into another box (nested).
* `flatMap()` → You open each box and **dump all items** into one big pile.

---

# 🔄 Summary

* `map()` → Always 1 output per input.
* `flatMap()` → Zero, one, or many outputs per input (and flattens them).
* Commonly used for **tokenization, expanding datasets, filtering**.
