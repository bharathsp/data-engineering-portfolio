# 🔄 **What is Dynamic Sharing in Spark?**

Dynamic sharing = Spark’s **Unified Memory Manager** (introduced in Spark 1.6) feature where **execution memory and storage memory share space dynamically**.

* Before (Static model): Execution = 60%, Storage = 40% (fixed).
* Now (Unified model): **Execution and Storage can borrow from each other**.

👉 This means:

* If execution (shuffles/joins) needs more → it can evict cached data from storage.
* If storage (cached DataFrames) needs more → it can borrow unused execution memory.

---

# 📊 **Memory Layout in Unified Manager**

Let’s say an executor has **8 GB memory**.

* Reserved: \~300 MB
* User memory: \~2 GB (\~25%)
* Spark memory: \~6 GB (\~75%)

Inside **Spark memory (6 GB)**:

* No hard 60/40 split.
* Execution & Storage dynamically share it.

---

# ⚡ **Example of Dynamic Sharing**

### Case 1: Heavy Computation, Little Caching

* Execution needs 5 GB
* Storage uses 1 GB
  ✅ Execution borrows from Storage → cached data may be evicted.

### Case 2: Heavy Caching, Light Computation

* Storage needs 4 GB (caching a DataFrame)
* Execution only needs 2 GB
  ✅ Storage borrows unused execution space.

### Case 3: Both Compete

* Execution = 4 GB
* Storage = 4 GB
  But only 6 GB total → execution wins priority, storage may evict cached data.

---

# 🖼️ **Analogy**

Imagine a **shared office desk 🪑**:

* **Execution = worker doing tasks** (needs space for files).
* **Storage = filing cabinet** (keeps documents handy).
* If the worker needs more space, the cabinet shrinks (eviction).
* If the worker leaves space unused, the cabinet expands.
* But the **worker always has priority** if they need more room.

---

# ✅ **Why Dynamic Sharing Matters**

* 📈 **Better utilization** → no wasted memory (unlike static 60/40).
* ⚡ **Faster jobs** → execution gets priority, reducing spills to disk.
* 🔄 **Flexibility** → adapts automatically to workload (ETL vs caching-heavy).

---

# 📌 **Summary**

* **Dynamic sharing = Execution & Storage memory share pool flexibly**.
* Execution has priority → storage data may be evicted.
* Avoids wasted memory, improves performance.
